<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
    <title>Isaac Clayton</title>
    <subtitle>A cozy little corner of the web.</subtitle>
    <link rel="self" type="application/atom+xml" href="https://slightknack.dev/atom.xml"/>
    <link rel="alternate" type="text/html" href="https://slightknack.dev"/>
    <generator uri="https://www.getzola.org/">Zola</generator>
    <updated>2025-01-30T00:00:00+00:00</updated>
    <id>https://slightknack.dev/atom.xml</id>
    <entry xml:lang="en">
        <title>What&#x27;s up with Haskell&#x27;s do notation?</title>
        <published>2025-01-30T00:00:00+00:00</published>
        <updated>2025-01-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/do-notation/"/>
        <id>https://slightknack.dev/blog/do-notation/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/do-notation/">&lt;p&gt;Managing side effects in &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;index.php?title=Functional_programming#Purity&quot;&gt;pure&lt;&#x2F;a&gt; functional programming
languages has &lt;a href=&quot;&#x2F;pdfs&#x2F;church-lambda.pdf&quot;&gt;always been&lt;&#x2F;a&gt; something of a challenge.
Functions in &lt;em&gt;purely&lt;&#x2F;em&gt; functional languages produce outputs
solely dependent on their inputs, by definition. Purity
makes it easy to reason about functions:
because all context is explicit, functions also become easy to break
apart and refactor.&lt;&#x2F;p&gt;
&lt;p&gt;The issue, however, with &lt;em&gt;explicit&lt;&#x2F;em&gt; context is that it quickly
becomes verbose. Unlike imperative languages, I&#x2F;O is no
longer as simple as a call to print: each function that prints
something requires a &lt;em&gt;context&lt;&#x2F;em&gt; to print it in, and must
return this context to the function that called it for later use (lest
the output be lost).&lt;&#x2F;p&gt;
&lt;p&gt;Like a game of hot potato, this I&#x2F;O context must be handed up and
down the call stack, passing through the hands of every function in between.
A task as simple as adding logging to a deep leaf function becomes an
immense &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;6310961&#x2F;how-do-i-do-logging-in-haskell#answer-6311338&quot;&gt;chore&lt;&#x2F;a&gt;, as every function that calls the
leaf function that now performs I&#x2F;O must accept and return an I&#x2F;O context.&lt;&#x2F;p&gt;
&lt;p&gt;Practical functional languages—those of the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Lisp_(programming_language)&quot;&gt;Lisp&lt;&#x2F;a&gt; and
&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;ML_(programming_language)&quot;&gt;ML families&lt;&#x2F;a&gt;—tend to take the easy way out by adding an imperative
&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ocaml.org&#x2F;docs&#x2F;mutability-imperative-control-flow&quot;&gt;escape hatch&lt;&#x2F;a&gt;. I&#x2F;O is special-cased: every function
“implicitly” takes a global context in which to print. While practically
viable, this solution is inflexible and can get messy when there are many
types of side effects that useful programs need to perform.&lt;&#x2F;p&gt;
&lt;p&gt;Personally, I am a fan of the more composable &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;homepages.inf.ed.ac.uk&#x2F;gdp&#x2F;publications&#x2F;Effect_Handlers.pdf&quot;&gt;&lt;em&gt;Algebraic
Effects&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; approach to handling side effects.
While probably deserving an essay in their own right,
Algebraic Effects neatly unify &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.n-a-n-o.com&#x2F;lisp&#x2F;cmucl-tutorials&#x2F;LISP-tutorial-12.html&quot;&gt;dynamically scoped&lt;&#x2F;a&gt; &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;monte.readthedocs.io&#x2F;en&#x2F;latest&#x2F;intro.html#object-capability-discipline&quot;&gt;capabilities&lt;&#x2F;a&gt;
with the benefits of &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Effect_system&quot;&gt;type system&lt;&#x2F;a&gt; and inference.
While &lt;em&gt;definitionally&lt;&#x2F;em&gt; more complex than a language with
implicit side effects, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-effect-types&quot;&gt;in &lt;em&gt;practice&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, Algebraic Effects are deceptively
simple. You can write code as if it were imperative.
The compiler keeps track of what effects are used where,
threading context as needed, and lowers your imperative-looking code
to something functional, pure, and easy to reason about.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;i-swear-this-is-not-a-monad-tutorial&quot;&gt;I swear this is not a monad tutorial&lt;&#x2F;h1&gt;
&lt;p&gt;Another way to manage side effects are through &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;All_About_Monads&quot;&gt;&lt;em&gt;Monads&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, as
exemplified by Haskell et … uh, just Haskell, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lean-lang.org&#x2F;functional_programming_in_lean&#x2F;monads.html&quot;&gt;really&lt;&#x2F;a&gt;. Monads describe a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;wiki.haskell.org&#x2F;Type_class&quot;&gt;class of
types&lt;&#x2F;a&gt; with associated properties that generally make them
amenable to modeling side effects.&lt;&#x2F;p&gt;
&lt;p&gt;This is not a monad tutorial, so with complete lack of tact, I’d
like to restate that a Monad is, in general, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Monad_(functional_programming)#More_examples&quot;&gt;anything that is
thenable&lt;&#x2F;a&gt;. Semantically, Monads are quite simple: A Monad is a class
of types where the following three operations are available, and
obey the so-called &lt;em&gt;Monad Laws&lt;&#x2F;em&gt; (which I describe later):&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Return&lt;&#x2F;em&gt;, which wraps a value in the default context.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;)&lt;&#x2F;em&gt;, which takes two contexts, and merges them
together as if one happened after the other.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Bind (&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;)&lt;&#x2F;em&gt;, which takes a value in a context, applies a
transformation to that value, and produces a new context.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In Haskell we’d define a Monad as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Monad m &lt;&#x2F;span&gt;&lt;span&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m a
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(&amp;gt;&amp;gt;) &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m a &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m b &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m b
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(&amp;gt;&amp;gt;=) &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m a &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m b&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m b
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that, in Haskell, both &lt;em&gt;then&lt;&#x2F;em&gt; (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;) and &lt;em&gt;bind&lt;&#x2F;em&gt;
(&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;) are defined as infix operators.&lt;&#x2F;p&gt;
&lt;p&gt;There are many different instances of Monads that exist in the wild. A
relatively simple Monad is &lt;code&gt;Maybe&lt;&#x2F;code&gt;, whose context is whether
or not a value exists. The implementation is not too complex:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- The value exists or it does not.
&lt;&#x2F;span&gt;&lt;span&gt;data &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Maybe&lt;&#x2F;span&gt;&lt;span&gt; a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; a | &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;instance &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Monad Maybe &lt;&#x2F;span&gt;&lt;span&gt;where
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- By default the value exists.
&lt;&#x2F;span&gt;&lt;span&gt;  return a = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; a
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Preserve context and replace value.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(&amp;gt;&amp;gt;)&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; a) b = b
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(&amp;gt;&amp;gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing&lt;&#x2F;span&gt;&lt;span&gt; _ = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Can only transform existing values.
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(&amp;gt;&amp;gt;=)&lt;&#x2F;span&gt;&lt;span&gt; (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just&lt;&#x2F;span&gt;&lt;span&gt; a) f = f a
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(&amp;gt;&amp;gt;=) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing&lt;&#x2F;span&gt;&lt;span&gt; _ = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And here’s how you would use return, then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;), and bind
(&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;) with the Maybe Monad:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Maybe
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Just 7
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Bye&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Nothing
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span&gt;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(+) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Just 9
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;These allow us to chain together monadic operations.
Note that in the last example, the context wrapping the value &lt;code&gt;7&lt;&#x2F;code&gt; is
preserved (e.g. we get &lt;code&gt;Just 9&lt;&#x2F;code&gt;). If we were to use
&lt;code&gt;Nothing&lt;&#x2F;code&gt; instead, we would get &lt;code&gt;Nothing&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span&gt;. &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(+) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Nothing
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Because we can’t &lt;em&gt;add two&lt;&#x2F;em&gt; to a value we don’t know!&lt;&#x2F;p&gt;
&lt;p&gt;Now the infix operator syntax for chaining monads is nice,
especially when writing point-free code, because we can define
these monadic transformations a bit like steps in a pipeline:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;get &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;AddressBook &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Maybe String
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;parse_email &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Maybe Email
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;send_email &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Email &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Maybe Thread
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;get contacts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Euclid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= parse_email
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= send_email message
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This example is short and reads well, because &lt;code&gt;parse_email&lt;&#x2F;code&gt; and
&lt;code&gt;send_email message&lt;&#x2F;code&gt; are functions with the exact type
signatures we expect at each stage in the pipeline.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;points-and-legos&quot;&gt;Points and legos&lt;&#x2F;h1&gt;
&lt;p&gt;Sometimes, however, the lego bricks in our pipeline don’t quite lock
together, as we have to adopt a style that uses &lt;em&gt;points&lt;&#x2F;em&gt;. In a
point-ful style, we use explicit anonymous functions (i.e.
&lt;em&gt;lambdas&lt;&#x2F;em&gt;) to pipe values together. I like to remember that the
arrow in a lambda is &lt;em&gt;pointy&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;add_two &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Int &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Int
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Point-free style
&lt;&#x2F;span&gt;&lt;span&gt;add_two = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;(+) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- Pointed style
&lt;&#x2F;span&gt;&lt;span&gt;add_two = \n -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;+ n
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To demonstrate the increased verbosity of using explicit points with
Monadic operations, here is the previous email snippet rewritten in a
point-ful style, using lambdas:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;get contacts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Euclid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= (\raw_email -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  parse_email raw_email
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;gt;&amp;gt;= (\email -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    send_email message email))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is, admittedly, quite a lot worse than:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;get contacts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Euclid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= parse_email
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= send_email message
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Although Haskell is generally pretty flexible, and provides plenty
of tools for wrangling pointed expressions into their equivalent
point-free forms, there are times where a pointed style is
simpler to understand than the convoluted currying and type
wrangling that may be required to enforce a strict
point-free style.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;do-notation-at-last&quot;&gt;Do notation at last&lt;&#x2F;h1&gt;
&lt;p&gt;Enter, Haskell’s &lt;em&gt;do notation&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s do notation is a compact notation for writing monadic
pipelines: it is powerful syntactic sugar that helps make
composing Monads easier. Here is the previous email snippet
written as a &lt;code&gt;do&lt;&#x2F;code&gt; expression:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  raw_email &amp;lt;- get contacts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Euclid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  email &amp;lt;- parse_email raw_email
&lt;&#x2F;span&gt;&lt;span&gt;  send_email message email
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which almost reads like imperative code. (This surface-level
similarity to straight-line code can be a pitfall for
beginners, but more on that later.)&lt;&#x2F;p&gt;
&lt;p&gt;So how does do notation work?&lt;&#x2F;p&gt;
&lt;p&gt;Do notation is syntactic sugar for the standard then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;) and bind
(&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;) operators. Each line in a &lt;code&gt;do&lt;&#x2F;code&gt; block is chained with the next using
A monadic operator.&lt;&#x2F;p&gt;
&lt;p&gt;To clarify, let’s look at a simple case with two lines. When we have two
simple expressions, one after another, like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;do&lt;&#x2F;code&gt; expression will desugar to the then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;) operator:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Nothing &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is &lt;code&gt;Nothing&lt;&#x2F;code&gt;.
When an line yields a wrapped monadic value, we can use &lt;code&gt;&amp;lt;-&lt;&#x2F;code&gt; to
extract the value inside the Monad for use in the rest of the
expression:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  seven &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;7
&lt;&#x2F;span&gt;&lt;span&gt;  return (seven + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This &lt;code&gt;&amp;lt;-&lt;&#x2F;code&gt; desugars to the bind (&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;) operator and a lambda as
follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Just &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= (\seven -&amp;gt; return (seven + &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that an implicit lambda was introduced, wrapping the rest
of the &lt;code&gt;do&lt;&#x2F;code&gt; expression. This is where the power of the &lt;code&gt;do&lt;&#x2F;code&gt;
expression lies: it allows us to express multiple pointed binds as a
straight-line series of expressions, which &lt;em&gt;eliminates nesting&lt;&#x2F;em&gt; and
becomes easier to read. The context of the previous expression is
transparently carried forward to the next, meaning we don’t have
to write out deeply-nested callbacks. Do notation slices apart
nested monadic transformations at the joints.&lt;&#x2F;p&gt;
&lt;p&gt;Haskell’s do notation is deeply related to &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;koka-lang.github.io&#x2F;koka&#x2F;doc&#x2F;book.html#sec-with&quot;&gt;&lt;em&gt;with notation&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;
in Koka (which does for Algebraic Effects what do
notation does for Monads) and &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;gleam.run&#x2F;news&#x2F;v0.25-introducing-use-expressions&#x2F;&quot;&gt;&lt;em&gt;use notation&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; in
Gleam. How these map to Haskell’s do notation (via the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;siraben.dev&#x2F;2020&#x2F;02&#x2F;20&#x2F;free-monads.html&quot;&gt;&lt;em&gt;Free Monad&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;) will perhaps be
the topic of another post.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;when-do-notation-doesn-t-run-sequentially&quot;&gt;When do notation doesn’t… run sequentially&lt;&#x2F;h1&gt;
&lt;p&gt;There are, however, a couple of pitfalls, which trap those new
to Haskell. On the surface, do notation looks similar to
imperative code: people coming from imperative languages
gravitate towards using &lt;code&gt;do&lt;&#x2F;code&gt; in simple cases where an idiomatic
point-free style is more appropriate. Using &lt;code&gt;do&lt;&#x2F;code&gt; can
needlessly complicate simple code:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  line &amp;lt;- get_line ()
&lt;&#x2F;span&gt;&lt;span&gt;  return line
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;While ostensibly sensible, this do block becomes:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;get_line () &amp;gt;&amp;gt; (\line -&amp;gt; return line)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is equivalent to:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;get_line ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a lot shorter (and point free)!&lt;&#x2F;p&gt;
&lt;p&gt;The second pitfall beginners face is not ever learning about the Monadic
operations that underlie do notation. (Which is a pitfall I hope I have
addressed in this post.)&lt;&#x2F;p&gt;
&lt;p&gt;To elaborate, do notation is usually used as a shorthand in
contexts that require I&#x2F;O. This tight coupling in
presentation may cause beginners to think that do notation is just
‘how one does’ imperative-style I&#x2F;O in Haskell. In reality, do notation
is a much more powerful tool: it can handle &lt;em&gt;any&lt;&#x2F;em&gt; Monad, not
just the IO Monad.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, thinking of do notation as an ‘imperative escape hatch’ is
also incorrect and has its pitfalls. Consider the following snippet:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;get_line &lt;&#x2F;span&gt;&lt;span&gt;:: () -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;IO String
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;print_line &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;IO &lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;friend = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  name &amp;lt;- get_line ()
&lt;&#x2F;span&gt;&lt;span&gt;  print_line (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;++ name)
&lt;&#x2F;span&gt;&lt;span&gt;  return name
&lt;&#x2F;span&gt;&lt;span&gt;  print_line &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Unreachable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Casper the Ghost&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s say you run this snippet, type &lt;code&gt;James&lt;&#x2F;code&gt; and hit enter. What is
printed, and who ends up as your &lt;code&gt;friend&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;Adopting an imperative lens, one might think:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;First, we store &lt;code&gt;&quot;James&quot;&lt;&#x2F;code&gt; in the &lt;code&gt;name&lt;&#x2F;code&gt; variable. Next, we print
&lt;code&gt;Hello, James&lt;&#x2F;code&gt;. We then encounter &lt;code&gt;return name&lt;&#x2F;code&gt; right in the middle
of our &lt;code&gt;do&lt;&#x2F;code&gt; block: since &lt;code&gt;return&lt;&#x2F;code&gt; short circuits control flow in
most other languages, it must certainly do the same in Haskell, so our
&lt;code&gt;friend&lt;&#x2F;code&gt; would be &lt;code&gt;&quot;James&quot;&lt;&#x2F;code&gt;, and the only output we should see would
be that of the first print statement…&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Right?&lt;&#x2F;p&gt;
&lt;p&gt;Wrong.&lt;&#x2F;p&gt;
&lt;p&gt;We’d actually end up with &lt;code&gt;friend = &quot;Casper the Ghost&quot;&lt;&#x2F;code&gt;, and we would
see the following as output:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Hello&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;James
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#7697d6;&quot;&gt;Unreachable
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Why?&lt;&#x2F;p&gt;
&lt;p&gt;Do notation is just sugar for chaining Monads: it is not
&lt;em&gt;actually&lt;&#x2F;em&gt; imperative code. Unlike other languages, &lt;code&gt;return&lt;&#x2F;code&gt; does
&lt;em&gt;not&lt;&#x2F;em&gt; short-circuit control flow: &lt;code&gt;return&lt;&#x2F;code&gt; is a normal
function like any other:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;a &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;m a
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In the case of &lt;code&gt;IO&lt;&#x2F;code&gt;, it just wraps a string in an I&#x2F;O context,
creating an &lt;code&gt;IO String&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;io_string &lt;&#x2F;span&gt;&lt;span&gt;:: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;IO String
&lt;&#x2F;span&gt;&lt;span&gt;return = io_string
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;With these definitions in place, we could desugar the above example as
follows:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;friend = get_line ()
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;gt;&amp;gt;= (\name -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    print_line (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;++ name)
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;&amp;gt; io_string name
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;&amp;gt; print_line &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Unreachable&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    &amp;gt;&amp;gt; io_string &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Casper the Ghost&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, &lt;code&gt;return name&lt;&#x2F;code&gt; in the middle reduces to creating an
&lt;code&gt;IO String&lt;&#x2F;code&gt; that is immediately discarded by the following
Monadic then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;). This is very important:&lt;&#x2F;p&gt;
&lt;p&gt;Do notation does &lt;em&gt;not&lt;&#x2F;em&gt; imply sequential imperative
evaluation. (This is especially true because Haskell is
&lt;em&gt;lazy&lt;&#x2F;em&gt;.)&lt;&#x2F;p&gt;
&lt;h1 id=&quot;the-monad-laws-at-last&quot;&gt;The Monad Laws at last!&lt;&#x2F;h1&gt;
&lt;p&gt;With that it mind, I can finally motivate an
aesthetic presentation of the three &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Monad_laws&quot;&gt;Monad Laws&lt;&#x2F;a&gt; using do-notation.
These are rules that then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;), bind (&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;), and return must follow
for an instance of the &lt;code&gt;Monad&lt;&#x2F;code&gt; typeclass to &lt;em&gt;actually&lt;&#x2F;em&gt; be a monad, mathematically.
(If you break the Monad Laws, the &lt;em&gt;Monad Police&lt;&#x2F;em&gt; will
show up and throw you in &lt;em&gt;Monad Jail&lt;&#x2F;em&gt; where you will labor
on the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;All_About_Monads#A_physical_analogy_for_monads&quot;&gt;&lt;em&gt;Monad Assembly Line&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; until all values lost
have been bound then returned to their former state of &lt;em&gt;purity&lt;&#x2F;em&gt;. Ahem.)&lt;&#x2F;p&gt;
&lt;h2 id=&quot;left-identity&quot;&gt;Left identity&lt;&#x2F;h2&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;This:&lt;&#x2F;th&gt;
&lt;th&gt;becomes:&lt;&#x2F;th&gt;
&lt;&#x2F;tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  y &amp;lt;- return x
&lt;&#x2F;span&gt;&lt;span&gt;  f y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  f x
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;&#x2F;table&gt;
&lt;h2 id=&quot;right-identity&quot;&gt;Right identity&lt;&#x2F;h2&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;This:&lt;&#x2F;th&gt;
&lt;th&gt;becomes:&lt;&#x2F;th&gt;
&lt;&#x2F;tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  x &amp;lt;- m
&lt;&#x2F;span&gt;&lt;span&gt;  return x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  m
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;&#x2F;table&gt;
&lt;h1 id=&quot;associativity&quot;&gt;Associativity&lt;&#x2F;h1&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;th&gt;This:&lt;&#x2F;th&gt;
&lt;th&gt;or:&lt;&#x2F;th&gt;
&lt;th&gt;becomes:&lt;&#x2F;th&gt;
&lt;&#x2F;tr&gt;
&lt;tr&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  y &amp;lt;- &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    x &amp;lt;- m
&lt;&#x2F;span&gt;&lt;span&gt;    f x
&lt;&#x2F;span&gt;&lt;span&gt;  g y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  x &amp;lt;- m
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;    y &amp;lt;- f x
&lt;&#x2F;span&gt;&lt;span&gt;    g y
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;td&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  x &amp;lt;- m
&lt;&#x2F;span&gt;&lt;span&gt;  y &amp;lt;- f x
&lt;&#x2F;span&gt;&lt;span&gt;  g y
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;td&gt;
&lt;&#x2F;table&gt;
&lt;h1 id=&quot;what-s-to-do-has-been-done&quot;&gt;What’s to do has been done&lt;&#x2F;h1&gt;
&lt;p&gt;So, to recap:&lt;&#x2F;p&gt;
&lt;p&gt;Side effects in pure functional languages
require propagating context, which results in
verbose code that is brittle to change. Haskell
circumvents this issue with Monads, which are a general way to
wrap a value in a context, and chain transformations on
a value within a given context.&lt;&#x2F;p&gt;
&lt;p&gt;However, operations on Monads—when written in a pointed
style—can quickly become verbose and nested. Do
notation is a simple syntax for flattening complex
chains of operations, offering a number of advantages over the
traditional then (&lt;code&gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;) and bind (&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;) syntax.&lt;&#x2F;p&gt;
&lt;p&gt;Those new to Haskell coming from imperative languages
often misinterpret the core calculus of do notation and use it
overzealously. However, by knowing the Monadic operations that
underlie do notation, one can learn when to use it to drastically
simplify code.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-s-up-with-haskell-s-do-notation&quot;&gt;What’s up with Haskell’s do notation?&lt;&#x2F;h2&gt;
&lt;p&gt;So you’ve read a lot about do notation but
I still haven’t explained &lt;em&gt;what the big deal is&lt;&#x2F;em&gt;.
Apologies. Talk about burying the lede.&lt;&#x2F;p&gt;
&lt;p&gt;Human languages, like English, are typically read in a linear sequence, from beginning to end.
Like programming languages, human languages map to &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Parse_tree#Nomenclature&quot;&gt;parse trees&lt;&#x2F;a&gt;, according to a
grammar—or set of rules—and we can ascribe semantic &lt;em&gt;meaning&lt;&#x2F;em&gt; to those trees.&lt;&#x2F;p&gt;
&lt;p&gt;Most human languages favor parse trees that &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Branching_(linguistics)#Full_trees&quot;&gt;branch&lt;&#x2F;a&gt; in a particular direction.
English, for example, is primarily a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Right-branching_sentences_in_English&quot;&gt;right-branching&lt;&#x2F;a&gt; language,
meaning that right-branching sentences are more common, due to the grammar of the language favoring their construction.
A right-branching sentence starts with a &lt;em&gt;subject&lt;&#x2F;em&gt; and is followed by a sequence of modifiers
that progressively add more information about the subject. To borrow &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;upload.wikimedia.org&#x2F;wikipedia&#x2F;commons&#x2F;6&#x2F;66&#x2F;Branching6.jpg&quot;&gt;an image&lt;&#x2F;a&gt; from Wikipedia,
after a certain point in a sentence, all subsequent nodes branch right:&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;content&#x2F;branching.svg&quot; alt=&quot;A parse tree for the sentence: &#x27;The child did not try to eat anything&#x27;. From &#x27;did&#x27; onward, the tree grows down and to the right.&quot;&gt;
&lt;p&gt;Speakers of English are pretty good at processing deeply-nested trees that branch to the right.
Reading right-branching sentences doesn’t feel like parsing some complicated grammatical structure.
The nesting, while deep, is simple: we always branch to the right.
Because the nesting is simple, we can treat the tree almost as a linear sequence:
we can ignore the nesting, because it is trivial.
I feel like humans are pretty good at communicating ideas by starting with a subject
and progressively adding information,
as opposed to incrementally constructing some sort of
complex tree structure the mind, which is then evaluated.&lt;&#x2F;p&gt;
&lt;p&gt;How is this related to do notation?&lt;&#x2F;p&gt;
&lt;p&gt;Haskell is also a language, and it also maps to parse trees.
Parse trees in Haskell, like in English, can lean to the left or to the right.
And when chaining operations together, like with Monads,
the parse trees can tend to lean pretty far in one direction.
Consider, for example, our pointed email-parsing example from earlier:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span&gt;get contacts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Euclid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;= (\raw_email -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;  parse_email raw_email
&lt;&#x2F;span&gt;&lt;span&gt;  &amp;gt;&amp;gt;= (\email -&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;    send_email message email))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In case it’s not visible from the intendation, this is a right-branching parse tree!&lt;&#x2F;p&gt;
&lt;p&gt;When we rewrite this expression using do-notation, the code is flattened:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;haskell&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-haskell &quot;&gt;&lt;code class=&quot;language-haskell&quot; data-lang=&quot;haskell&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;do
&lt;&#x2F;span&gt;&lt;span&gt;  raw_email &amp;lt;- get contacts &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Euclid&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  email &amp;lt;- parse_email raw_email
&lt;&#x2F;span&gt;&lt;span&gt;  send_email message email
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is a lot easier to read,
because humans are pretty good at communicating ideas by starting with a subject
and progressively adding information.
The nesting, of course, is still there,
but the &lt;code&gt;do&lt;&#x2F;code&gt; keyword keys us in that the parse tree will be leaning to the right.
The nesting, while deep, is simple, so we can ignore it.
If Monads are context, then each line is information added to that context.
By eliminating nesting, it becomes easier to communicate hard ideas.&lt;&#x2F;p&gt;
&lt;p&gt;That’s what’s up with Haskell’s do notation.&lt;&#x2F;p&gt;
&lt;p&gt;We see this flattening a lot, in the space of programming languages.
A classic example is method call syntax, going from &lt;code&gt;foo(bar(baz))&lt;&#x2F;code&gt; to &lt;code&gt;baz.bar().foo()&lt;&#x2F;code&gt;,
which makes it easier to flatten a chain function calls, eliminating nesting along the way.
And in imperative languages, the sequencing of statements with &lt;code&gt;;&lt;&#x2F;code&gt;
can be seen as a kind of flattening composition in of itself.
Notational tweaks like these, while seemingly simple,
can make it a lot easier to express hard programs,
and thus solve hard problems.&lt;&#x2F;p&gt;
&lt;p&gt;That’s all for today. In a future post, I hope to explore how Koka’s
&lt;em&gt;with&lt;&#x2F;em&gt; &lt;em&gt;notation&lt;&#x2F;em&gt; is a variation of Haskell’s do notation
specialized for modeling Algebraic Effects using the Free
Monad. Until next time!&lt;&#x2F;p&gt;
&lt;div class=&quot;boxed&quot;&gt;
&lt;p&gt;Thank you to my friend &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.uzpg.me&#x2F;&quot;&gt;Uzay&lt;&#x2F;a&gt; for reviewing an earlier draft of this post!
(It has been sitting on my hard drive for way to long.)&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Reasoning Trace</title>
        <published>2025-01-28T00:00:00+00:00</published>
        <updated>2025-01-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/reasoning-trace/"/>
        <id>https://slightknack.dev/blog/reasoning-trace/</id>
        
        <summary type="html">&lt;p&gt;&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;2501.12948&quot;&gt;DeepSeek-R1-Zero is cool&lt;&#x2F;a&gt;. I &lt;a href=&quot;&#x2F;blog&#x2F;constraints&quot;&gt;wrote about reasoning models&lt;&#x2F;a&gt; before o1, and I’m excited to the way this area of research has been cracked wide open, it seems. It’s also remarkably simple. I’m messing around with llama (running locally!), trying to see if I can at least partially reproduce the results (for fun). I figure I can collect reasoning chains and then adapt some existing RLHF code to fine-tune the model on successful chains vs. unsuccessful chains, maybe by prefixing the response with a reward token, a la &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;arxiv.org&#x2F;pdf&#x2F;2106.01345&quot;&gt;decision transformer&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;N.B.&lt;&#x2F;em&gt; I’m doing something a little more complicated where the model is allowed to write and run python programs to arrive at an answer. I’m testing on some &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;projecteuler.net&#x2F;archives&quot;&gt;&lt;em&gt;Project Euler&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; questions, because I think they are a fun blend of a mathematical and computational challenge.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;It turns out that &lt;code&gt;llama-3.2-3b-instruct&lt;&#x2F;code&gt; is pretty bad at &lt;em&gt;Project Euler&lt;&#x2F;em&gt;. I’ve tested it on the first &lt;s&gt;77&lt;&#x2F;s&gt; 109 questions, and it’s gotten about 12 right. About half the time (43 cases), it gets stuck in a reasoning loop and never produces an answer (like generating Python code that isn’t properly indented and then trying everything to debug the syntax error &lt;em&gt;except indenting the code&lt;&#x2F;em&gt;). Sometimes this makes llama frustrated:&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>I&#x27;m offline, and that&#x27;s OK</title>
        <published>2025-01-22T00:00:00+00:00</published>
        <updated>2025-01-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/offline-ok/"/>
        <id>https://slightknack.dev/blog/offline-ok/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/offline-ok/">&lt;p&gt;&lt;em&gt;Stop showing me spinners, show me what’s loading.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Recently, while on a trip between cities, we hit a patch of road without
good coverage. While on long trips, I enjoy reading books I have saved
on my phone. I have some books on my phone that exist as PDFs stored on
Google Drive.&lt;&#x2F;p&gt;
&lt;p&gt;Before the trip, I started reading a few books while online, and I know
they’re downloaded. Even so, while trying to navigate the hierarchy
folders to reach said books, I was met by spinner after spinner.
Sometimes a spinner appeared because I was offline, and Drive was trying
to fetch the contents of the Drive over the network. Other times, the
spinner spun for a few seconds while loading the contents of the folder
from disk. The problem is that there is absolutely no way to tell the
difference between the two. I know I’m offline: stop showing me
spinners¹, tell me what’s loading.&lt;&#x2F;p&gt;
&lt;p&gt;When a user is offline, experience should degrade gracefully. This does
not mean that the worse the connection is the worse the experience
becomes. Rather, the offline experience should be as thought out as the
online experience, despite the degraded connection. What differentiates
incredible UX from good UX is consistently meeting user expectations,
&lt;em&gt;especially&lt;&#x2F;em&gt; when things go wrong…&lt;&#x2F;p&gt;
&lt;p&gt;…“You are offline, the contents of this folder will load once back
online.” Is as easy as a spinner, and much more informative.&lt;&#x2F;p&gt;
&lt;p&gt;…If data is cached locally, show that data, even if incomplete, and tell
me what’s loading, or needs to load. Reassure me that it’s on the
device, and it will load.&lt;&#x2F;p&gt;
&lt;p&gt;…Whenever there is not a bounded guarantee on how long something will
take to load (e.g. when reading anything from disk or over a network),
show some meaningful indication of progress. This includes updating the
UI non-destructively as data loads in (don’t shift stuff around),
showing a loading bar with uniform progress, and informing the user what
work is being done in a humane manner.&lt;&#x2F;p&gt;
&lt;p&gt;…When loading data or performing an operation with non-uniform progress
(e.g. over a network), tell me why the work is progressing slowly or
quickly. For example, one could keep a persistent indicator next to a
loading bar telling me when my connection is poor, when it is fast, when
the connection has dropped and is being reestablished, and when a
connection could not be established at all.&lt;&#x2F;p&gt;
&lt;p&gt;Figuring out how to incorporate these elements into a modern UI is a
hard problem, but one that has already mostly been solved.&lt;&#x2F;p&gt;
&lt;p&gt;The biggest issue, most likely, is economical: justifying the added cost
of having offline support. This is a false dichotomy: by default, all
applications are offline, and a network connection enhances this default
behaviour. Offline support is not an addition, but a foundation: if your
app is architected to work well when offline, it will be more robust
when progressively enhanced with internet connectivity.&lt;&#x2F;p&gt;
&lt;p&gt;Building robust apps is important: users will not keep coming back to an
app that is broken, no matter how useful it is when it works. Users may
be offline at times. Don’t make your app the point of a user’s
frustration: an offline experience shouldn’t be a broken one.&lt;&#x2F;p&gt;
&lt;p&gt;At the end of the day, whether one is “connected to the Internet” or not
is not a question with a binary answer. A connection may be perfectly
fine for texting, yet not hold up when said conversation moves to a
video call. A high-latency, yet high-throughput connection might work
great while streaming, but terribly while gaming online. What is being
offline but having a connection with extremely high latency and
extremely low throughput?&lt;&#x2F;p&gt;
&lt;p&gt;Internet connectivity depends on the state of the physical
infrastructure of the internet. This will never be something application
authors—not even Google—will have complete control over. Even if strong
connectivity is guaranteed, consider that users may want to use your app
offline. The default is no connectivity, enhanced by a network
connection. Applications that are built to be local-first are more
robust at an architectural level, and lend themselves to developing an
incredible user experience with greater ease.&lt;&#x2F;p&gt;
&lt;p&gt;I’m offline, and that’s OK. And even if I’m not, stop showing me
spinners: show me what’s loading.&lt;&#x2F;p&gt;
&lt;p&gt;—&lt;&#x2F;p&gt;
&lt;p&gt;1. Spinners originally existed to show that an app was doing work in
the background, and that the UI hadn’t frozen. In the era of
asynchronous UI updates and multithreaded code, the UI should never
freeze, especially not because of a network request. The spinner,
therefore, is a redundant artifact from a bygone era. Stop using
spinners.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>One day with Zig, Raylib, and jj</title>
        <published>2024-12-25T00:00:00+00:00</published>
        <updated>2024-12-25T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/zig-raylib/"/>
        <id>https://slightknack.dev/blog/zig-raylib/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/zig-raylib/">&lt;h1 id=&quot;merry-christmas&quot;&gt;Merry Christmas!&lt;&#x2F;h1&gt;
&lt;p&gt;Back from the mission, first semester at MIT is in the books! Now I am at home, with family, on a break from school.&lt;&#x2F;p&gt;
&lt;p&gt;A couple days ago, I was telling my younger brother how cool Zig (the programming language) was. He was like, “if Zig is so cool, why don’t you … like, use it?” Oof. So I &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ziglang.org&#x2F;learn&#x2F;getting-started&#x2F;#managers&quot;&gt;installed Zig&lt;&#x2F;a&gt;, pulled in &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Not-Nik&#x2F;raylib-zig&quot;&gt;some neat bindings for raylib&lt;&#x2F;a&gt;, and spent the afternoon writing a little interactive scrabble board demo to make sure that I understood what I was talking about (while he worked on some music for it, which I haven’t yet included):&lt;&#x2F;p&gt;
&lt;iframe src=&quot;&#x2F;scrabble&quot; width=&quot;100%&quot; height=&quot;600px&quot; frameborder=&quot;0&quot;&gt;&lt;&#x2F;iframe&gt;
&lt;p&gt;So that I can stop worrying about this project and lay it to rest, I decided to write a little blog post. The above demo doesn’t really work on mobile, and it may be broken (Wasm, JS, about 1MB in size, etc.), so here’s a screenshot:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;scrabble-devlog.png&quot; alt=&quot;Screenshot of a scrabble board in a window on top of a Zed editor.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;When I showed my brother the demo, he was like, “that’s cool beta, but where’s the game?”&lt;&#x2F;p&gt;
&lt;p&gt;You can’t win every battle.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. “Maybe if you made it a game you could” — my brother&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Anyway, the code &lt;del&gt;will be&lt;&#x2F;del&gt; &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;slightknack&#x2F;scrabble&quot;&gt;is now up on GitHub&lt;&#x2F;a&gt;, it’s like &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;slightknack&#x2F;scrabble&#x2F;blob&#x2F;master&#x2F;src&#x2F;main.zig&quot;&gt;~500 lines&lt;&#x2F;a&gt; and has &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Not-Nik&#x2F;raylib-zig&quot;&gt;like one dependency&lt;&#x2F;a&gt; (&lt;code&gt;raylib-zig&lt;&#x2F;code&gt;) so it shouldn’t be too hard to get the native build working if you’d like to follow along then. The web build is a little hacky and left as an exercise to the reader.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;why-zig&quot;&gt;Why Zig&lt;&#x2F;h1&gt;
&lt;p&gt;I have been eyeballing Zig for a while. I think I first heard of the language via a talk Andrew Kelly gave at the recurse center … ah yep here it is: &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;Z4oYSByyRak?t=157&quot;&gt;&lt;em&gt;Software Should Be Perfect&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. 6 years ago, wow.&lt;&#x2F;p&gt;
&lt;p&gt;I really vibe with the language. From a language design PoV, generics through &lt;code&gt;comptime&lt;&#x2F;code&gt; functions is pretty fun. “Compiler as an interpreter over the static elements of the program” and all that. Also, I think @matklad has mentioned that there’s this goal of making Zig an incremental “real-time” compiler. Incrementally compiling code at 60 fps! Now that’s a goal I can get behind! From a tooling PoV, also very cool: I love the cross-compilation, and &lt;code&gt;build.zig&lt;&#x2F;code&gt;, while a bit to absorb all at once, is very useful and powerful, especially for e.g. embedding a C library like raylib.&lt;&#x2F;p&gt;
&lt;p&gt;I also came across the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tigerbeetle&#x2F;tigerbeetle&#x2F;blob&#x2F;main&#x2F;docs&#x2F;TIGER_STYLE.md&quot;&gt;TigerStyle document&lt;&#x2F;a&gt; out of TigerBeetle and it has changed the way I think about code. This project was for fun, but I can see how Zig can help scale the ideas in this document. It doesn’t try to hide anything from you. And like, aesthetically, I find the idea of e.g. statically allocating all memory up front to be very appealing.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;walk-me-through-the-code&quot;&gt;Walk me through the code&lt;&#x2F;h1&gt;
&lt;p&gt;I put &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;slightknack&#x2F;scrabble&quot;&gt;the code up on GitHub&lt;&#x2F;a&gt;, and I thought it would be fun to walk through some of it and point out some interesting stuff as we go along. Clone if you want to follow along!&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. I used &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jj-vcs&#x2F;jj&quot;&gt;jujutsu (jj)&lt;&#x2F;a&gt; to do version control instead of git (without colocating) so I am figuring out whether I try to convert the jj repo to a git repo or just &lt;code&gt;git init&lt;&#x2F;code&gt; and &lt;code&gt;push&lt;&#x2F;code&gt; without any history. I’ll read the jj docs, there’s probably an easy way to export&#x2F;convert&#x2F;colocate.&lt;&#x2F;p&gt;
&lt;p&gt;Update: Steve Klabnik, the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;stable&#x2F;book&#x2F;&quot;&gt;Rust book guy&lt;&#x2F;a&gt; (and now I guess also the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;steveklabnik.github.io&#x2F;jujutsu-tutorial&#x2F;introduction&#x2F;introduction.html&quot;&gt;jj tutorial guy&lt;&#x2F;a&gt;?) &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;lobste.rs&#x2F;s&#x2F;1wbfuj&#x2F;one_day_with_zig_raylib_jj#c_irzgui&quot;&gt;pointed out on Lobsters&lt;&#x2F;a&gt; that, because jj repos are backed by git repos, you can just &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;steveklabnik.github.io&#x2F;jujutsu-tutorial&#x2F;sharing-code&#x2F;remotes.html&quot;&gt;add a remote&lt;&#x2F;a&gt; and &lt;code&gt;jj git push&lt;&#x2F;code&gt;. In brief detail, we can add a git remote:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;jj&lt;&#x2F;span&gt;&lt;span&gt; git remote add origin git@github.com:slightknack&#x2F;scrabble.git
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then we can set a bookmark named &lt;code&gt;master&lt;&#x2F;code&gt; pointing at the most recent commit:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;jj&lt;&#x2F;span&gt;&lt;span&gt; bookmark set master
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which we can then push to GitHub, the bookmark becoming the &lt;code&gt;master&lt;&#x2F;code&gt; branch:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;jj&lt;&#x2F;span&gt;&lt;span&gt; git push&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt; --allow-new
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The integration jj has with git is very cool! From the &lt;em&gt;little time&lt;&#x2F;em&gt; I’ve spent using jj and the &lt;em&gt;lot of time&lt;&#x2F;em&gt; I’ve spent reading about jj, I think that jj’s UI is much nice than git’s. On Lobsters, I observed that perhaps “jj is positioned to ameliorate the git world as TS ameliorated JS”. I’d like to live in that world; I’d better blog about jj more.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The approach I took to writing this project was essentially the approach that Casey Muratori outlines in his post &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;caseymuratori.com&#x2F;blog_0015&quot;&gt;&lt;em&gt;Semantic Compression&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. I’m not going to explain it here, he does a much better job than I have space to. The core idea of this process is to add the next most obvious feature in the simplest way possible, not trying to abstract beforehand. Once a feature is working, gradually refactor out common ‘stack frames’ into structs, and functions that use those structs. Over time the codebase sort of organizes itself. I think this approach works really well when it comes to making game-like things, which makes sense: Muratori is a game programmer, after all.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. I kinda missed the whole AI train (long story) so all this code was written by hand, reading the documentation (e.g. the entire Zig language &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;ziglang.org&#x2F;documentation&#x2F;master&quot;&gt;is just one page&lt;&#x2F;a&gt;!), etc. Mistakes are my own!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;a-note-on-comptime&quot;&gt;A note on comptime&lt;&#x2F;h2&gt;
&lt;p&gt;I’d like to walk through the file and pull out interesting bits of code, just to give you a feel for the project, and maybe introduce some bits of Zig I found cool. The whole project largely exists in a single ~500 line &lt;code&gt;main.zig&lt;&#x2F;code&gt; file. At the top of the file, I have two imports:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; std = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;@import&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;std&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; rl = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;@import&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;raylib&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two pretty cool items of language design, right away:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;A top-level &lt;code&gt;const&lt;&#x2F;code&gt; like this means that this code is evaluated at compile-time (comptime)!&lt;&#x2F;li&gt;
&lt;li&gt;Symbols starting with &lt;code&gt;@&lt;&#x2F;code&gt;, like &lt;code&gt;@import&lt;&#x2F;code&gt;, are special to the compiler. &lt;code&gt;@import(&quot;std&quot;)&lt;&#x2F;code&gt; essentially adds a source file to the build, producing a struct, which we then can assign to a symbol, like &lt;code&gt;std&lt;&#x2F;code&gt;. Neat!&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;We see this idea of comptime echoed a lot. Modules are just comptime structs in other files. Types are first-class values at comptime. Generics are functions that return types at comptime. And so on.&lt;&#x2F;p&gt;
&lt;p&gt;After our imports, we embed some static resources in the binary, sounds and textures:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; image_table = @embedFile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.&#x2F;assets&#x2F;table-light.jpg&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_place = @embedFile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.&#x2F;assets&#x2F;place.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_pickup = @embedFile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.&#x2F;assets&#x2F;pickup.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_tap = @embedFile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.&#x2F;assets&#x2F;tap.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_shuffle = @embedFile(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.&#x2F;assets&#x2F;shuffle.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The comptime function &lt;code&gt;@embedFile&lt;&#x2F;code&gt; is pretty cool, similar to the &lt;code&gt;include_bytes!&lt;&#x2F;code&gt; macro in Rust.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;structs-and-the-shape-of-a-stack-frame&quot;&gt;Structs and the shape of a stack frame&lt;&#x2F;h2&gt;
&lt;p&gt;As I programmed, I ended up organizing game state into a few different structs, one generic:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Grid(rows, cols)&lt;&#x2F;code&gt;: fixed-size grid of squares, each square may contain a tile.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Tile&lt;&#x2F;code&gt;: A tile with a single letter on it.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Rack&lt;&#x2F;code&gt;: Contains a &lt;code&gt;Grid(1, 7)&lt;&#x2F;code&gt; and a &lt;code&gt;Button&lt;&#x2F;code&gt;, which can be used to refill the rack.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Bag&lt;&#x2F;code&gt;: Shuffles all 98 scrabble tiles and returns them one by one, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;harddrop.com&#x2F;wiki&#x2F;Random_Generator&quot;&gt;similar to tetris&lt;&#x2F;a&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Button&lt;&#x2F;code&gt;: A single button that can be clicked.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The &lt;code&gt;Grid&lt;&#x2F;code&gt; struct is generic. In Zig, this means it is a function that we call (at comptime!) with the number of rows and columns, to produce a concrete type with a statically-known size. We do this so we know how big of an array to allocate to hold all the tiles in the grid. I’m actually rather proud of this fact: by virtue of never using an allocator, this code never allocates on the heap! (Caveat, raylib internals.) Here’s how &lt;code&gt;Grid&lt;&#x2F;code&gt; is defined:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;Grid&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;comptime &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;num_rows&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;comptime &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;num_cols&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;return struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; Self = @This();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;rows&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= num_rows,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;cols&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span&gt;= num_cols,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;posX&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;posY&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;tile_width&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;tile_height&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;gap&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; like some text in a book, left to right, top to bottom
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;tiles&lt;&#x2F;span&gt;&lt;span&gt;: [num_rows * num_cols]?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Tile&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; methods, etc. ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Raylib is essentially an immediate mode library for graphics. Meaning, each frame, we have to generate a sequence of draw events that will produce the picture we see on the screen. Each of the above structs (except for &lt;code&gt;Bag&lt;&#x2F;code&gt;) has an &lt;code&gt;update&lt;&#x2F;code&gt; method and a &lt;code&gt;draw&lt;&#x2F;code&gt; method that can be called each frame. It’s refreshingly simple.&lt;&#x2F;p&gt;
&lt;p&gt;Again, I wrote the code in a procedural style and ‘pulled out stack frames’ as I went along. I wasn’t trying to take an object-oriented approach, or confine structs to a given interface. These were the patterns that emerged in the code that I pulled out of &lt;code&gt;main&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I don’t know why, but I find this to be such a fun way to code. Here’s the method that draws the grid, for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F;&#x2F; draw the grid background and all the tiles on the grid
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;draw&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;color&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;rl.Color&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; draw the grid background
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(0..self.rows) |row| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(0..self.cols) |col| {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;= @intCast(row);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;= @intCast(col);
&lt;&#x2F;span&gt;&lt;span&gt;            rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;drawRectangle&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;                self.posX + c * self.tile_width,
&lt;&#x2F;span&gt;&lt;span&gt;                self.posY + r * self.tile_height,
&lt;&#x2F;span&gt;&lt;span&gt;                self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;width&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;height&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;                color,
&lt;&#x2F;span&gt;&lt;span&gt;            );
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; draw the tiles on top
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(self.tiles) |maybe_tile| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(maybe_tile) |tile| {
&lt;&#x2F;span&gt;&lt;span&gt;            tile.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;draw&lt;&#x2F;span&gt;&lt;span&gt;(rl.Color.white, rl.Color.light_gray, rl.Color.black);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Isn’t that so … satisfying? I mean sure, it’s not a beautiful Haskell one-liner, yet it contains &lt;em&gt;exactly&lt;&#x2F;em&gt; everything that needs to happen, no less, and no more.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. I also really love Zig’s block syntax &lt;code&gt;|...| { ... }&lt;&#x2F;code&gt; for &lt;code&gt;for&lt;&#x2F;code&gt; and &lt;code&gt;if&lt;&#x2F;code&gt;. The way Zig does nulls is very cool and I’ll have to write about it some more sometime.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;The way I did tiles is pretty fun. Here’s a &lt;code&gt;Tile&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Tile &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;pos&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;rl.Vector2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;width&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;height&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;hover&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;f32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;thick&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;letter&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Note that &lt;code&gt;rl.Vector2&lt;&#x2F;code&gt; is a type defined by raylib (&lt;code&gt;rl&lt;&#x2F;code&gt;) and essentially amounts to two &lt;code&gt;f32&lt;&#x2F;code&gt;s. Elsewhere, &lt;code&gt;hover&lt;&#x2F;code&gt; is the height the tile is floating above the ground, and &lt;code&gt;letter&lt;&#x2F;code&gt; is a byte representing the ASCII code for the letter on the tile.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;animations-falling-into-place&quot;&gt;Animations falling into place&lt;&#x2F;h2&gt;
&lt;p&gt;What’s really great is how naturally the tile animations fall out of this. When we place a &lt;code&gt;Tile&lt;&#x2F;code&gt; in a &lt;code&gt;Grid&lt;&#x2F;code&gt;, the grid stores it in a linearized array, &lt;code&gt;Grid.tiles&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; like some text in a book, left to right, top to bottom
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;tiles&lt;&#x2F;span&gt;&lt;span&gt;: [num_rows * num_cols]?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Tile&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we update the grid each frame, we animate each tile in &lt;code&gt;tiles&lt;&#x2F;code&gt; towards the resting position it should be in. Here’s what that looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F;&#x2F; animate placed tiles towards their resting grid positions. should be called once per frame.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;update&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(0..self.rows) |row| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;(0..self.cols) |col| {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;= @intCast(col);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;i32 &lt;&#x2F;span&gt;&lt;span&gt;= @intCast(row);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; guaranteed to be within bounds
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; index = self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;toIndex&lt;&#x2F;span&gt;&lt;span&gt;(r, c).?;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; target = self.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;toTarget&lt;&#x2F;span&gt;&lt;span&gt;(r, c);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;var&lt;&#x2F;span&gt;&lt;span&gt; tile = &amp;amp;(self.tiles[index] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;orelse continue&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            tile.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;settleInPlace&lt;&#x2F;span&gt;&lt;span&gt;(target);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I have no clue whether there’s a better way to get a reference to &lt;code&gt;tile&lt;&#x2F;code&gt; than the approach I used. Surely there is, compared to this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;var&lt;&#x2F;span&gt;&lt;span&gt; tile = &amp;amp;(self.tiles[index] &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;orelse continue&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;tile.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;settleInPlace&lt;&#x2F;span&gt;&lt;span&gt;(target);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We have an array of optional tiles (&lt;code&gt;[]?Tile&lt;&#x2F;code&gt;) and a reference to an item in that array is a &lt;code&gt;*?Tile&lt;&#x2F;code&gt;, but we need a &lt;code&gt;*Tile&lt;&#x2F;code&gt;. I had fun here but there’s probably a very simple way to do this. I digress&lt;&#x2F;p&gt;
&lt;p&gt;We go through each tile and nudge it towards where it needs to be on the grid. The method &lt;code&gt;tile.settleInPlace&lt;&#x2F;code&gt; just nudges the tile towards the target position, and lowers the &lt;code&gt;hover&lt;&#x2F;code&gt;ing tile to the ground:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F;&#x2F; animate the tile towards a given target. should be called once per frame
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;settleInPlace&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Tile&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;target&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;rl.Vector2&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    self.pos = rl.math.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;vector2Lerp&lt;&#x2F;span&gt;&lt;span&gt;(self.pos, target, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0.3&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    self.hover = rl.math.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;lerp&lt;&#x2F;span&gt;&lt;span&gt;(self.hover, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0.0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0.08&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here &lt;code&gt;lerp&lt;&#x2F;code&gt; is a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;scratch.mit.edu&#x2F;projects&#x2F;40796964&#x2F;editor&#x2F;&quot;&gt;classic trick older than time&lt;&#x2F;a&gt;. I’m sure other people have their own names for this, but I don’t think it needs a name. I think of it as the &lt;code&gt;pos += (target - pos) &#x2F; speed&lt;&#x2F;code&gt; trick. In the APL tradition, if something is simple enough that it is about as long as its name, why name it?&lt;&#x2F;p&gt;
&lt;p&gt;We use a similar trick for when a tile is hovering over a grid. We want the tile to be “magnetically attracted” to the grid spaces but also follow the mouse. We can use the tension between two &lt;code&gt;lerp&lt;&#x2F;code&gt;s to make that happen:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F;&#x2F; animate the tile towards the mouse, biased towards the grid. should be called once per frame.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;followMouse&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Tile&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;mouse&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;rl.Vector2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;snap&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;rl.Vector2&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; pos_mouse = rl.math.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;vector2Lerp&lt;&#x2F;span&gt;&lt;span&gt;(self.pos, mouse, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0.1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; pos_snap = rl.math.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;vector2Lerp&lt;&#x2F;span&gt;&lt;span&gt;(pos_mouse, snap, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0.2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    self.pos = pos_snap;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The parameter &lt;code&gt;snap&lt;&#x2F;code&gt; is computed elsewhere, but it’s the screenspace coordinates of the nearest grid cell.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. I was considering keeping track of velocities to make the tile springy and give it some mass (another classic trick). Here’s what that looks like, if curious&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;vel += vel * friction + (target - pos) &#x2F; speed
&lt;&#x2F;span&gt;&lt;span&gt;pos += vel
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;What is really cool about this procedural stateless approach to animating tiles is that when we add a tile to a grid, or have it follow the mouse, it naturally smoothly travels to the right place. Complex dynamic behaviour is best driven by simple behavior compounded over time.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;randomness-and-the-bag&quot;&gt;Randomness and the bag&lt;&#x2F;h2&gt;
&lt;p&gt;One thing I wanted to get right was the &lt;code&gt;Bag&lt;&#x2F;code&gt;. I didn’t want to allocate anything, but I wanted the distribution of scrabble tiles to be correct. Well, the second part is easy, we just need a bag with each tile:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F;&#x2F; don&amp;#39;t ask
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;scrabble_bag&lt;&#x2F;span&gt;&lt;span&gt;: *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;98&lt;&#x2F;span&gt;&lt;span&gt;:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKXJQZ&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Scrabble_letter_distributions&quot;&gt;Thank you Wikipedia&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;We’ll just allocate, on the stack I suppose, a single large struct with space to hold all these letters:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Bag &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;scrambled&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;98&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. I don’t know how Zig internally deals with large structs like this. I know that, in principle, when a function is called, structs are passed by value, “making a fresh immutable copy”. I would hope that in practice Zig optimizes this to a reference to an earlier stack frame or similar.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;All we’ll do is shuffle our &lt;code&gt;scrabble_bag&lt;&#x2F;code&gt; into &lt;code&gt;Bag.scrambled&lt;&#x2F;code&gt;, then empty out the bag by incrementing &lt;code&gt;next&lt;&#x2F;code&gt;, shuffling again when we reach the end. Oh. How does one shuffle in Zig? I will note that this was a little non-trivial to find docs for because there is a deprecated API that shows up higher in the search results, but the long story short is we want to use &lt;code&gt;std.Random&lt;&#x2F;code&gt; via &lt;code&gt;std.crypto.random&lt;&#x2F;code&gt;, and that’s something you can look up.&lt;&#x2F;p&gt;
&lt;p&gt;Here’s the code that shuffles the bag:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;fresh&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Bag &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; rand = std.crypto.random;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;var &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loc&lt;&#x2F;span&gt;&lt;span&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;98&lt;&#x2F;span&gt;&lt;span&gt;]&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;= scrabble_bag.*;
&lt;&#x2F;span&gt;&lt;span&gt;    rand.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;shuffle&lt;&#x2F;span&gt;&lt;span&gt;(u8, &amp;amp;loc);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;return Bag&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        .scrambled = loc,
&lt;&#x2F;span&gt;&lt;span&gt;        .next = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Figuring out &lt;code&gt;var loc: [98]u8&lt;&#x2F;code&gt; also took a little work. Zig doesn’t have full Hindley-Milner type inference, as Rust does. Sometimes you have to guide the compiler along by using &lt;code&gt;@as&lt;&#x2F;code&gt; or explicit bindings. Not necessarily a bad thing, it’s good to know what types are flowing through the program. A good balance between Rust’s type inference magic and Austral’s &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;borretti.me&#x2F;article&#x2F;introducing-austral#anti-features&quot;&gt;purposeful lack thereof&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. This makes total sense, in the context of Zig’s comptime! When generic types are built function calls, type information flows in one direction. Flowing program information backwards is what we see in languages like Prolog, where rules can be thought of as bidirectional functions. I briefly explored this direction in a compiler I am working on, which has (had?) first-class support for datalog-like queries. “Type inference as a comptime datalog query.” Maybe someday.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Okay, and just for completion’s sake, here’s the rest of &lt;code&gt;Bag&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F;&#x2F; pick a tile from the bag. if the bag is empty, replace with a fresh bag.
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;pick&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;: *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Bag&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; drawn = self.scrambled[self.next];
&lt;&#x2F;span&gt;&lt;span&gt;    self.next += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(self.next &amp;gt;= self.scrambled.len) {
&lt;&#x2F;span&gt;&lt;span&gt;        self.* = Bag.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;fresh&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;return&lt;&#x2F;span&gt;&lt;span&gt; drawn;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I was surprised that &lt;code&gt;std.crypto.random&lt;&#x2F;code&gt; worked out of the box for the wasm build of the demo. From my experience with Rust and &lt;code&gt;rand&lt;&#x2F;code&gt;, this is not always something that automatically works.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;my-main-man&quot;&gt;My main man&lt;&#x2F;h2&gt;
&lt;p&gt;We’ve already talked about most of the project, structured as follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Imports and embeddings&lt;&#x2F;li&gt;
&lt;li&gt;Structs and methods&lt;&#x2F;li&gt;
&lt;li&gt;The &lt;code&gt;main&lt;&#x2F;code&gt; function
&lt;ul&gt;
&lt;li&gt;Startup code&lt;&#x2F;li&gt;
&lt;li&gt;Per-frame loop&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I’d like to talk about the &lt;code&gt;main&lt;&#x2F;code&gt; function, because it’s the beating heart of this whole thing. As I mentioned, I wrote this project by writing a main function, and then pulling out functions and bundles of local variables as things got repetitive. So &lt;code&gt;main&lt;&#x2F;code&gt; really is the driver of the whole codebase, both literally and conceptually.&lt;&#x2F;p&gt;
&lt;p&gt;Raylib is delightful to work with. Here’s how we set up our window:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;anyerror&lt;&#x2F;span&gt;&lt;span&gt;!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; screenWidth = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;800&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; screenHeight = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;600&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;initWindow&lt;&#x2F;span&gt;&lt;span&gt;(screenWidth, screenHeight, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;game game&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;initAudioDevice&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;setTargetFPS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;60&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;defer&lt;&#x2F;span&gt;&lt;span&gt; rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;closeWindow&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;defer&lt;&#x2F;span&gt;&lt;span&gt; rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;closeAudioDevice&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Startup code and per-frame loop
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I love how I can use &lt;code&gt;defer&lt;&#x2F;code&gt; here. It’s a nice way to pair together functions that must be called together, but at different times. A lot of old C APIs expect this sort of “manual nesting by the programmer” to enter and exit over e.g. taking a callback. I prefer &lt;code&gt;defer&lt;&#x2F;code&gt; over RAII, though. At least in this context: raylib is simple and global and single-threaded, what do I know.&lt;&#x2F;p&gt;
&lt;p&gt;The startup code that comes after builds a lot of structs. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;var&lt;&#x2F;span&gt;&lt;span&gt; grid = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;GridBoard&lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    .posX = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;175&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    .posY = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;45&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    .tile_width = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    .tile_height = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;30&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    .gap = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    .tiles = [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;]?&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Tile&lt;&#x2F;span&gt;&lt;span&gt;{null} ** (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;15 &lt;&#x2F;span&gt;&lt;span&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;15&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; more structs
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I considered factoring this out into a bunch of unique &lt;code&gt;init&lt;&#x2F;code&gt; functions, but that’s like squeezing a water balloon. The lines are just going to pop up somewhere else in the codebase, and I’d rather have all this initialization code in the same place for easy tweaking. Maybe if the project were bigger.&lt;&#x2F;p&gt;
&lt;p&gt;Then we load all the sound and image data for the game. Remember, this was embedded into the binary earlier with &lt;code&gt;@embedFile&lt;&#x2F;code&gt;. Honestly I am so impressed by how nice and logically organized raylib’s API is, what a treat:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; image_table_mem = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadImageFromMemory&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.jpg&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, image_table);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; image_table_tex = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadTextureFromImage&lt;&#x2F;span&gt;&lt;span&gt;(image_table_mem);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_pickup_mem = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadWaveFromMemory&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, sound_pickup);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_place_mem = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadWaveFromMemory&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, sound_place);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_tap_mem = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadWaveFromMemory&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, sound_tap);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_shuffle_mem = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadWaveFromMemory&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;.wav&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, sound_shuffle);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_pickup_wav = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadSoundFromWave&lt;&#x2F;span&gt;&lt;span&gt;(sound_pickup_mem);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_place_wav = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadSoundFromWave&lt;&#x2F;span&gt;&lt;span&gt;(sound_place_mem);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_tap_wav = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadSoundFromWave&lt;&#x2F;span&gt;&lt;span&gt;(sound_tap_mem);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;const&lt;&#x2F;span&gt;&lt;span&gt; sound_shuffle_wav = rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;loadSoundFromWave&lt;&#x2F;span&gt;&lt;span&gt;(sound_shuffle_mem);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; per-frame loop.
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If only I were better at naming things, haha.&lt;&#x2F;p&gt;
&lt;p&gt;Onto the per-frame loop. We start by clearing and drawing the background. Another useful appearance of &lt;code&gt;defer&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span&gt;(!rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;windowShouldClose&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;    rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;beginDrawing&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;defer&lt;&#x2F;span&gt;&lt;span&gt; rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;endDrawing&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;clearBackground&lt;&#x2F;span&gt;&lt;span&gt;(rl.Color.white);
&lt;&#x2F;span&gt;&lt;span&gt;    rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;drawTexture&lt;&#x2F;span&gt;&lt;span&gt;(image_table_tex, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, rl.Color.white);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;defer&lt;&#x2F;span&gt;&lt;span&gt; rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;drawFPS&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ... update and draw
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I wanted to draw the FPS counter on top of everything, which I can do by drawing it last through &lt;code&gt;defer&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;There’s a lot of pretty dense game state updating that I don’t want to bore you with, but it’s nothing complicated. I probably should break it up into a few functions. Here’s how we update and draw the grid:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span&gt;grid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;update&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;grid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;draw&lt;&#x2F;span&gt;&lt;span&gt;(rl.Color.dark_brown.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;alpha&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0.2&lt;&#x2F;span&gt;&lt;span&gt;));
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And to give you an idea of the logic, here’s the logic for trying to pick up a tile:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;zig&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-zig &quot;&gt;&lt;code class=&quot;language-zig&quot; data-lang=&quot;zig&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(mouse_click) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;(grid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;pickUp&lt;&#x2F;span&gt;&lt;span&gt;(tile.pos)) |got_tile| {
&lt;&#x2F;span&gt;&lt;span&gt;        tile = got_tile;
&lt;&#x2F;span&gt;&lt;span&gt;        tile_visible = true;
&lt;&#x2F;span&gt;&lt;span&gt;        rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;playSound&lt;&#x2F;span&gt;&lt;span&gt;(sound_place_wav);
&lt;&#x2F;span&gt;&lt;span&gt;    } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;else if &lt;&#x2F;span&gt;&lt;span&gt;(rack.grid.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;pickUp&lt;&#x2F;span&gt;&lt;span&gt;(tile.pos)) |got_tile| {
&lt;&#x2F;span&gt;&lt;span&gt;        tile = got_tile;
&lt;&#x2F;span&gt;&lt;span&gt;        tile_visible = true;
&lt;&#x2F;span&gt;&lt;span&gt;        rl.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;playSound&lt;&#x2F;span&gt;&lt;span&gt;(sound_pickup_wav);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There’s similar code for placing a tile, how to swap a tile, updating the tile to follow the mouse, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;Again, look at that beautiful raylib API for playing a sound!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;final-thoughts&quot;&gt;Final thoughts&lt;&#x2F;h1&gt;
&lt;p&gt;I had a lot of fun messing around with Zig and raylib!&lt;&#x2F;p&gt;
&lt;p&gt;I really do enjoy picking up new tools like this. Trying out a project like this is low stakes, and experience is the best teacher. I have read a lot of Zig code, but this is the first time I really write something. Thank you Andrew Kelley and everyone who works on Zig and, well, @raysan5 for raylib (and @Not-Nik for the bindings)!&lt;&#x2F;p&gt;
&lt;p&gt;One thing I missed coming from Rust was pattern matching. Zig doesn’t have pattern matching, I suppose? Reading some discussion online, it seems to be that Zig’s &lt;code&gt;switch&lt;&#x2F;code&gt; statement—the moral equivalent to Rust’s &lt;code&gt;match&lt;&#x2F;code&gt;—compiles to a jump table, but pattern matching can lead to non-obvious control flow. I can see how that goes against the ethos of Zig, but man pattern matching would be nice. Maybe there’s a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;TheHonestHare&#x2F;zkinder&quot;&gt;library that emulates pattern matching&lt;&#x2F;a&gt;? Could a library generate pattern matching code at comptime? Who knows!&lt;&#x2F;p&gt;
&lt;p&gt;I don’t know if I will add more to this game, but if I do, stay tuned. I have been thinking about what it would take to add online multiplayer. I have also been sketching out a fun little CRDT library. We’ll see what happens.&lt;&#x2F;p&gt;
&lt;p&gt;Oh yeah! and I totally forgot to touch on &lt;code&gt;build.zig&lt;&#x2F;code&gt;! I’ll have to touch on that the next time I write about Zig.&lt;&#x2F;p&gt;
&lt;p&gt;And jujutsu was really fun. I even got to use &lt;code&gt;amend&lt;&#x2F;code&gt;. Another topic for another post!&lt;&#x2F;p&gt;
&lt;p&gt;Merry Christmas, and to all a good night!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Intelligence and the importance of consistency</title>
        <published>2024-08-13T00:00:00+00:00</published>
        <updated>2024-08-13T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/constraints/"/>
        <id>https://slightknack.dev/blog/constraints/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Note: This post was published before the release of o1 on 2024-9-12.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;People are quick to point out that Large Language Models (LLMs) tend to
hallucinate facts and lack the ability to reason. LLMs are not grounded
in reality. Hallucination is an architectural limitation due to how
Transformers, as auto-regressive sequence predictors, are constructed.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Dealing with Cyclic Data in Rust, Part I</title>
        <published>2022-07-22T00:00:00+00:00</published>
        <updated>2022-07-22T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/rust-cycles/"/>
        <id>https://slightknack.dev/blog/rust-cycles/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Or, a &lt;em&gt;GhostCell Deep Dive&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In this two-part series, we build &lt;em&gt;GhostCell&lt;&#x2F;em&gt; from first principles. In &lt;em&gt;Part I&lt;&#x2F;em&gt; we go over the underlying theory required to understand GhostCell. This post’s been sitting on my hard drive for about 9 months, so I’ve decided to bite the bullet, split what I’ve written in two, and hit publish on &lt;em&gt;Part I&lt;&#x2F;em&gt;. Hope you enjoy!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Over the past month or so, something I’ve repeatedly run into is &lt;em&gt;GhostCell&lt;&#x2F;em&gt;, a technique that (ab)uses Rust’s lifetime system to detach ownership of data from the permission to mutate it. In short, this makes it possible to write datatypes that rely on shared interior mutability (think doubly-linked lists and other cyclical graph-like structures). In this post I wanted to explore Rust’s lifetime system to explain GhostCell from first principles, and why it’s kinda a big deal.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Building a Rust Mentality</title>
        <published>2022-07-21T00:00:00+00:00</published>
        <updated>2022-07-21T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/shift/"/>
        <id>https://slightknack.dev/blog/shift/</id>
        
        <summary type="html">&lt;p&gt;What really helped me begin to &lt;em&gt;grok&lt;&#x2F;em&gt; how Rust really worked was working towards building an understanding of how its &lt;em&gt;compiler&lt;&#x2F;em&gt; works.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Late Night Conversations about Nothing in Particular</title>
        <published>2022-07-15T00:00:00+00:00</published>
        <updated>2022-07-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/late/"/>
        <id>https://slightknack.dev/blog/late/</id>
        
        <summary type="html">&lt;h2 id=&quot;the-beginning-of-the-end-of-today&quot;&gt;The Beginning of the End (of Today)&lt;&#x2F;h2&gt;
&lt;p&gt;As I write this today, it’s tomorrow.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;and-we-re-talking-about-school&quot;&gt;And… We’re talking about school?&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;N.B. This post is not about school, bear with me.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Throughout the school year, I’m usually pretty consistent with my sleep schedule. It’s like a rhythm, every hour of my day planned out. I wake up at 5:55 exactly, do some morning studying (it’s always so much easier to get stuff done in the morning), shower an hour later, breakfast, and I’m out the door.&lt;&#x2F;p&gt;
&lt;p&gt;School’s rhythmic too. This was my last year of high school, my senior year. I think I overdid it a bit, to be honest. 6 APs and 2 college math courses, on top of, you know, everything else that goes on in life, is a bit much for anyone, &lt;em&gt;especially&lt;&#x2F;em&gt; for a simple-minded guy like me. I appreciate the rhythm school brings to my life.&lt;&#x2F;p&gt;
&lt;p&gt;So why am I writing this at 1 AM?&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Traits as implicit conversion</title>
        <published>2022-02-28T00:00:00+00:00</published>
        <updated>2022-02-28T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/traits-as/"/>
        <id>https://slightknack.dev/passerine/traits-as/</id>
        
        <content type="html" xml:base="https://slightknack.dev/passerine/traits-as/">&lt;p&gt;The joy of writing a &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;passerine.io&quot;&gt;new programming language&lt;&#x2F;a&gt; is coming up with novel ideas and seeing if they stick.&lt;&#x2F;p&gt;
&lt;p&gt;The challenge I’m attempting to solve stems from dealing with different types of objects that share common structure or behavior. For this reason I’ve been thinking a lot about how to rectify open&#x2F;closed enumerations, traits, and type constructors.&lt;&#x2F;p&gt;
&lt;p&gt;Traditional object-oriented languages deal with this through the use of inheritance. For example since both a &lt;code&gt;Wizard&lt;&#x2F;code&gt; and a &lt;code&gt;Person&lt;&#x2F;code&gt; have a &lt;code&gt;name&lt;&#x2F;code&gt;, they may both inherit from a single &lt;code&gt;Named&lt;&#x2F;code&gt; class. In Java, we may write this as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;name;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;age;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Wizard &lt;&#x2F;span&gt;&lt;span&gt;extends &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;title;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;skill;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is all well and dandy, but problems quickly arise. Java only supports single inheritance, so if we want a new class to extend both &lt;code&gt;Named&lt;&#x2F;code&gt; and, say &lt;code&gt;Aged&lt;&#x2F;code&gt;, we’d either have to create a new class (like &lt;code&gt;NamedAndAged&lt;&#x2F;code&gt;, gross), or use a language with &lt;em&gt;multiple inheritance&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Multiple inheritance sucks for other reasons, though, mostly due to the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Multiple_inheritance#The_diamond_problem&quot;&gt;diamond dependency problem&lt;&#x2F;a&gt;. If we even create a class that inherits from two superclasses with the same field, which field gets used? Does the object have two fields?&lt;&#x2F;p&gt;
&lt;p&gt;This is a problem as old as the hills, and it’s why we’ve developed sayings—like ‘always choose composition over inheritance’—that have been passed down from developer to developer, generation after generation.&lt;&#x2F;p&gt;
&lt;p&gt;We don’t have to be stuck with the pains inheritance, though! Inheritance is really just ensuring that different objects share certain structure and&#x2F;or behavior. Ultimately this is what composition over inheritance means: Instead of having a &lt;code&gt;Person&lt;&#x2F;code&gt; that is &lt;code&gt;Named&lt;&#x2F;code&gt;, just make a &lt;code&gt;Person&lt;&#x2F;code&gt; have a &lt;code&gt;Name&lt;&#x2F;code&gt;, and pass that &lt;code&gt;Name&lt;&#x2F;code&gt; around when required:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Name &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;String &lt;&#x2F;span&gt;&lt;span&gt;name;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;int &lt;&#x2F;span&gt;&lt;span&gt;age;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Name &lt;&#x2F;span&gt;&lt;span&gt;name;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;While nice, this required that person carry around a &lt;code&gt;name&lt;&#x2F;code&gt; field; if the name can be derived from existing class data, this may be redundant. We could use a method, of course:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;class &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Name &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;() { 
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ... 
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But the problem here is that there’s no real &lt;em&gt;consistency&lt;&#x2F;em&gt; between the various ways of representing that a &lt;code&gt;Person&lt;&#x2F;code&gt; has a name. Do we access a field, call a method, etc?&lt;&#x2F;p&gt;
&lt;p&gt;But you know the solution to this! Just use typeclasses&#x2F;traits&#x2F;interfaces, you shout! Instead of adding methods and fields ad-hoc, we declare a shared &lt;code&gt;trait&lt;&#x2F;code&gt; (to use the Rust parlance) with common behavior:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Named &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then, if we have a person, we can implement &lt;code&gt;Named&lt;&#x2F;code&gt; for &lt;code&gt;Person&lt;&#x2F;code&gt; to show that a person indeed has a name:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;age&lt;&#x2F;span&gt;&lt;span&gt;:  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Named for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Person &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    name(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.name.to_string()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can access this field using regular method call syntax, like &lt;code&gt;person.name()&lt;&#x2F;code&gt;. If we implement another trait that &lt;em&gt;also&lt;&#x2F;em&gt; has a name method, then we must use Rust’s Uniform Function Call Syntax (UFCS) to disambiguate: &lt;code&gt;Named::name(&amp;amp;person)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Whatever you call it, the core idea behind traits&#x2F;typeclasses&#x2F;interfaces&#x2F;etc. is simple: define a single interface with a number of behaviors through which the underlying object is accessed.&lt;&#x2F;p&gt;
&lt;p&gt;My largest issue with these systems is that &lt;em&gt;another layer&lt;&#x2F;em&gt; on top of the language itself. This description may not be entirely clear, so let’s jump into some examples in Passerine:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;a-modest-proposal&quot;&gt;A modest proposal&lt;&#x2F;h1&gt;
&lt;p&gt;Say we have a struct; it’s for a &lt;code&gt;Person&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;type Person = {
&lt;&#x2F;span&gt;&lt;span&gt;    name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  Nat,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we wanted to make a new &lt;code&gt;Person&lt;&#x2F;code&gt;, we’d just construct it:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;Gerald&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  69,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can write functions that update &lt;code&gt;Person&lt;&#x2F;code&gt;, too:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;birthday = Person { name, age          } 
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Person { name, age: age + 1 }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So far, this is all pretty standard. When you think about it, constructing a &lt;code&gt;Person&lt;&#x2F;code&gt; is just wrapping a bare struct in the &lt;code&gt;Person&lt;&#x2F;code&gt; newtype. In fact, this is completely valid:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;inner = { name: &amp;quot;Bob&amp;quot;, age: 27 }
&lt;&#x2F;span&gt;&lt;span&gt;bob = Person inner
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In essence, &lt;code&gt;Person&lt;&#x2F;code&gt; is a constructor: a function that takes some data and produces some data of that type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat } -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;span&gt;       = { name,         age      } -&amp;gt; Person { name, age }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In fact, for any type we define, we essentially get the following constructor for free:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Type : Inner -&amp;gt; Type
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By default, &lt;code&gt;Inner&lt;&#x2F;code&gt; is a single type: it’s literally the inner contents of &lt;code&gt;Type&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dynamic-dispatch&quot;&gt;Dynamic dispatch&lt;&#x2F;h1&gt;
&lt;p&gt;This brings me to traits. A trait is essentially a set of different objects that share the same behavior. In Rust, for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Animal &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;feed&lt;&#x2F;span&gt;&lt;span&gt;()  -&amp;gt; String;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;speak&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; String;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Anything that you can &lt;code&gt;feed&lt;&#x2F;code&gt; or &lt;code&gt;say&lt;&#x2F;code&gt; can be defined to be an &lt;code&gt;Animal&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Cat
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; A cat is an Animal
&lt;&#x2F;span&gt;&lt;span&gt;impl Animal for Cat {
&lt;&#x2F;span&gt;&lt;span&gt;    fn feed()  { &amp;quot;not hungry&amp;quot;.to_string() }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;speak&lt;&#x2F;span&gt;&lt;span&gt;() {      &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;meow!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;.to_string() }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Traits are useful for modeling systems that expect different objects with defined shared behavior. For example, we can define a trait that represents &lt;code&gt;Iterator&lt;&#x2F;code&gt; over an arbitrary stream:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Abridged from Rust&amp;#39;s standard library
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Iterator &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Item&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;Self::&lt;&#x2F;span&gt;&lt;span&gt;Item&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Anything has a notion of being advanced via &lt;code&gt;next&lt;&#x2F;code&gt;, whether that be moving a cursor through an array or traversing nodes in a tree, can be used as an &lt;code&gt;Iterator&lt;&#x2F;code&gt;. For example, here’s how we might iterate through a &lt;code&gt;Vec&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;VecIter&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    vec:   Vec&amp;lt;T&amp;gt;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Ignoring some lifetime stuff for the sake of simplicity
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Iterator for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;VecIter&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;type &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Item &lt;&#x2F;span&gt;&lt;span&gt;= T;
&lt;&#x2F;span&gt;&lt;span&gt;    
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.index += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.vec.get(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.index - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;vec_to_iter&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;vec&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;T&amp;gt;) -&amp;gt; VecIter {
&lt;&#x2F;span&gt;&lt;span&gt;    VecIter { index: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;, vec }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That’s simple enough. calling &lt;code&gt;vec_to_iter(vec![1, 2, 3])&lt;&#x2F;code&gt; will produce a &lt;code&gt;VecIter&lt;&#x2F;code&gt; which can be used as an &lt;code&gt;impl Iterator&amp;lt;Item=usize&amp;gt;&lt;&#x2F;code&gt;, an iterator over the numbers 1, 2, and 3.&lt;&#x2F;p&gt;
&lt;p&gt;But if you were to represent an iterator as an &lt;em&gt;actual type&lt;&#x2F;em&gt;, how would you go about doing that?&lt;&#x2F;p&gt;
&lt;p&gt;Well, we know that an iterator produces &lt;code&gt;Item&lt;&#x2F;code&gt;s of a certain type, and has a single function that advances state:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Iterator&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Item&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;: Box&amp;lt;dyn FnMut() -&amp;gt; Option&amp;lt;Item&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And then why don’t we just have &lt;code&gt;vec_to_iter&lt;&#x2F;code&gt; return, well, an &lt;code&gt;Iterator&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Again, completely ignoring the borrow checker lol
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;vec_to_iter&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;vec&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;T&amp;gt;) -&amp;gt; Iterator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; index = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; vec = vec;
&lt;&#x2F;span&gt;&lt;span&gt;    
&lt;&#x2F;span&gt;&lt;span&gt;    Iterator {
&lt;&#x2F;span&gt;&lt;span&gt;        next: Box::new(|| {
&lt;&#x2F;span&gt;&lt;span&gt;            index += &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            vec.get(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.index - &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As you can see, an iterator is just a concrete type containing a higher-order function. In this non-trait version, implementing &lt;code&gt;Iterator&lt;&#x2F;code&gt; is as simple as &lt;em&gt;constructing&lt;&#x2F;em&gt; Iterator.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; iter = vec_to_iter(vec![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;])
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;(vec.next)(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Some(1)
&lt;&#x2F;span&gt;&lt;span&gt;(vec.next)(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Some(2)
&lt;&#x2F;span&gt;&lt;span&gt;(vec.next)(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; Some(3)
&lt;&#x2F;span&gt;&lt;span&gt;(vec.next)(); &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; None
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust makes this a bit harder because none of the code we just wrote would actually compile, but this should illustrate the point.&lt;&#x2F;p&gt;
&lt;p&gt;But the point is: traits can be represented as plain old types.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; Agda and inference&lt;&#x2F;p&gt;
&lt;p&gt;TODO: Write about how Agda builds off this, it’s really cool!&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Anyway, let’s hop back to Passerine.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;wizards-are-people-too&quot;&gt;Wizards are people too.&lt;&#x2F;h1&gt;
&lt;p&gt;Starting with our definition for &lt;code&gt;Person&lt;&#x2F;code&gt; from earlier, let’s also define a &lt;code&gt;Wizard&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;type Person = {
&lt;&#x2F;span&gt;&lt;span&gt;    name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  Nat,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;type Wizard = {
&lt;&#x2F;span&gt;&lt;span&gt;    title: String,
&lt;&#x2F;span&gt;&lt;span&gt;    name: String,
&lt;&#x2F;span&gt;&lt;span&gt;    skill:  Nat,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now wizards are people too. All wizards are actually as physically fit as a 25 year old (how else do you think they are so darn fast?), but their outward age-defined appearance is a pure function of &lt;code&gt;skill&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;So let’s say we have a function that takes a &lt;code&gt;Person&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;call_for_dinner = Person { name, .. } -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    println &amp;quot;Hey {name}, it&amp;#39;s time for dinner! Come and eat!&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now wizards are people too: wouldn’t it be nice if we could call our wizard friends over for dinner as well?&lt;&#x2F;p&gt;
&lt;p&gt;We could write a conversion function that temporarily converts a &lt;code&gt;Wizard&lt;&#x2F;code&gt; into a &lt;code&gt;Person&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;wizard_to_person = Wizard { title, name, skill } 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &amp;quot;{name} the {title}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        age:  25 + skill &#x2F; 10,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So if we have a &lt;code&gt;Wizard&lt;&#x2F;code&gt;, say &lt;code&gt;merlin&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;merlin = Wizard {
&lt;&#x2F;span&gt;&lt;span&gt;    title: &amp;quot;Wise&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    name:  &amp;quot;Merlin&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    skill: 930,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can call &lt;code&gt;merlin&lt;&#x2F;code&gt; over to dinner:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;call_to_dinner (wizard_to_person merlin)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Hey Merlin the Wise, it’s time for dinner! Come and eat!&lt;&#x2F;p&gt;
&lt;p&gt;The only thing missing for this to be a trait system would be some way to convert &lt;code&gt;merlin&lt;&#x2F;code&gt; to a &lt;code&gt;Person&lt;&#x2F;code&gt; automatically…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;from-a-to-b&quot;&gt;from A to B&lt;&#x2F;h1&gt;
&lt;p&gt;So, back to constructors.&lt;&#x2F;p&gt;
&lt;p&gt;Remember that when we’re constructing a &lt;code&gt;Person&lt;&#x2F;code&gt;, &lt;code&gt;Person&lt;&#x2F;code&gt; essentially serves as a function with the following type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat } -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In other words, we take a record (i.e. struct) representing a person, and produce a semi-opaque object of type &lt;code&gt;Person&lt;&#x2F;code&gt;. Reasonable enough.&lt;&#x2F;p&gt;
&lt;p&gt;But what if we could make &lt;code&gt;Person&lt;&#x2F;code&gt; construct over additional types?&lt;&#x2F;p&gt;
&lt;p&gt;The most obvious extension would be some sort of row polymorphism (as Passerine aims to eventually be row-polymorphic, in the tradition of ML-style languages). If we provide a record with additional fields to &lt;code&gt;Person&lt;&#x2F;code&gt;, person should ignore those fields:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person { 
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;Joe&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;    age: &amp;quot;5&amp;quot;, 
&lt;&#x2F;span&gt;&lt;span&gt;    birthday: &amp;quot;2022-05-23&amp;quot; 
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In this case, the &lt;code&gt;birthday&lt;&#x2F;code&gt; field would be ignored. If we were to write this as a type, we could say that:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: Nat, age: String } 
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: Nat, age: String, .. } -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Remember that &lt;code&gt;|&lt;&#x2F;code&gt; is a sum type (i.e. enum). This is a bit redundant, as the former type is a subtype of the latter.&lt;&#x2F;p&gt;
&lt;p&gt;Taking some more creative liberties, let’s say that we want a person constructed with no &lt;code&gt;age&lt;&#x2F;code&gt; to take on a default value of &lt;code&gt;0&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;jack = Person { name: &amp;quot;Baby Jack&amp;quot; }
&lt;&#x2F;span&gt;&lt;span&gt;jack.age
&lt;&#x2F;span&gt;&lt;span&gt;-------- this is 0
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Whether this is a good idea or not is debatable, but it wouldn’t be too hard to write as a function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;baby_person = { name } -&amp;gt; Person { name, age: 0 }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If &lt;code&gt;Person&lt;&#x2F;code&gt; accepted this as well, we’d write the type of the &lt;code&gt;Person&lt;&#x2F;code&gt; constructor function as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String, age: Nat, .. }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String }
&lt;&#x2F;span&gt;&lt;span&gt;      -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s get a little crazy. Remember our &lt;code&gt;Wizards&lt;&#x2F;code&gt; from earlier? what if it was possible to construct a &lt;code&gt;Person&lt;&#x2F;code&gt; from a &lt;code&gt;Wizard&lt;&#x2F;code&gt;, you know, using our &lt;code&gt;wizard_to_person&lt;&#x2F;code&gt; routine:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;merlin = Wizard {
&lt;&#x2F;span&gt;&lt;span&gt;    title: &amp;quot;Wise&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    name:  &amp;quot;Merlin&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    skill: 930,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;Person merlin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This would mean that the &lt;code&gt;Person&lt;&#x2F;code&gt; constructor could really take anything of the following type:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person : { name: String, age: Nat }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String, age: Nat, .. }
&lt;&#x2F;span&gt;&lt;span&gt;       | { name: String }
&lt;&#x2F;span&gt;&lt;span&gt;       | Wizard
&lt;&#x2F;span&gt;&lt;span&gt;       | ...
&lt;&#x2F;span&gt;&lt;span&gt;      -&amp;gt; Person
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;In all these cases — wizards, row polymorphism, default parameters, or otherwise, what we’re trying to do is simple — treat a some type that isn’t a &lt;code&gt;Person&lt;&#x2F;code&gt; as a &lt;code&gt;Person&lt;&#x2F;code&gt; by extending the constructor. By extending the constructor, we’re essentially treating &lt;code&gt;Person&lt;&#x2F;code&gt; in the similitude of a trait: a common target for shared behavior, namely having a &lt;code&gt;name&lt;&#x2F;code&gt; and an &lt;code&gt;age&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In essence, we want &lt;em&gt;open membership&lt;&#x2F;em&gt; over &lt;code&gt;Person&lt;&#x2F;code&gt;’s constructor. What if we could define our own &lt;code&gt;Person T&lt;&#x2F;code&gt;, creating people from arbitrary people-likes of type &lt;code&gt;T&lt;&#x2F;code&gt;?&lt;&#x2F;p&gt;
&lt;p&gt;Something I’ve been considering is a &lt;code&gt;impl ... from&lt;&#x2F;code&gt; syntax, specifically for this purpose:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;-- So that `Person Wizard` works
&lt;&#x2F;span&gt;&lt;span&gt;impl Person from Wizard = 
&lt;&#x2F;span&gt;&lt;span&gt;    Wizard { title, name, skill } 
&lt;&#x2F;span&gt;&lt;span&gt;-&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;{name} the {title}&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    age:  25 + skill &#x2F; 10,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This, essentially, would add a case to &lt;code&gt;Person&lt;&#x2F;code&gt;’s constructor so that constructing a &lt;code&gt;Person&lt;&#x2F;code&gt; from a wizard now makes sense. This essentially acts as a form of dynamic dispatch!&lt;&#x2F;p&gt;
&lt;p&gt;In fact, we’re not limited to the second type being a named type. We could implement baby-by-default (the case where the default age is zero) in the following manner:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;impl Person from { name: String } =
&lt;&#x2F;span&gt;&lt;span&gt;    { name } -&amp;gt; Person { name, age: 0 }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is pretty cool! There are lots of things you can do, like defining a &lt;code&gt;Default&lt;&#x2F;code&gt; type that wraps unit, &lt;code&gt;()&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;type Default = ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we can add a default implementation to person!&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;impl Person from Default 
&lt;&#x2F;span&gt;&lt;span&gt;    = Default -&amp;gt; Person {
&lt;&#x2F;span&gt;&lt;span&gt;        name: &amp;quot;&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;        age:  0,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So now it’s possible to write:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person Default
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Or use row splicing to fill in a &lt;code&gt;Person&lt;&#x2F;code&gt; from the &lt;code&gt;Default&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;ug = Person {
&lt;&#x2F;span&gt;&lt;span&gt;    name: &amp;quot;ug&amp;quot;,
&lt;&#x2F;span&gt;&lt;span&gt;    .. Person Default,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Where &lt;code&gt;.. Person Default&lt;&#x2F;code&gt; essentially means fill the rest of this struct from &lt;code&gt;Person Default&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;But I guess you could argue that &lt;code&gt;Person&lt;&#x2F;code&gt; isn’t really a trait. Don’t we have this backwards? Wouldn’t we want to &lt;code&gt;impl Default from Person&lt;&#x2F;code&gt;, whatever that means?&lt;&#x2F;p&gt;
&lt;p&gt;Well yes and no. Let’s look at some iterators.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;iterators-in-passerine&quot;&gt;Iterators in Passerine&lt;&#x2F;h1&gt;
&lt;p&gt;So Passerine has a little problem, and it’s twofold:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;It only supports inductive datatypes (i.e. anything you could trivially serialize to JSON, no cycles).&lt;&#x2F;li&gt;
&lt;li&gt;Closures can only capture immutable values.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;In Rust we defined our type representing an iterator using, well, a mutable closure:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Iterator&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;Item&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;: Box&amp;lt;dyn FnMut() -&amp;gt; Option&amp;lt;Item&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So to model &lt;code&gt;Iterator&lt;&#x2F;code&gt; in Passerine, we’d essentially have to make the internal state explicit:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;type Iterator = all State Item -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    state: State,
&lt;&#x2F;span&gt;&lt;span&gt;    _next: State -&amp;gt; Option (State, Item)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which isn’t too bad, because we can define a function &lt;code&gt;next&lt;&#x2F;code&gt; that operates on iterators, instead of calling &lt;code&gt;iterator._next&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;next : all S I 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; (Iterator S I) 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Option (Iterator S I, T)
&lt;&#x2F;span&gt;&lt;span&gt;= Iterator { state, _next } -&amp;gt; match (_next state) {
&lt;&#x2F;span&gt;&lt;span&gt;    Some (new_state, item) -&amp;gt; Some (
&lt;&#x2F;span&gt;&lt;span&gt;        Iterator { state: new_state, _next }, 
&lt;&#x2F;span&gt;&lt;span&gt;        item,
&lt;&#x2F;span&gt;&lt;span&gt;    ),
&lt;&#x2F;span&gt;&lt;span&gt;    None -&amp;gt; None,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; In the future, it might be possible to model hidden state using Passerine’s effect system.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Yeah, it kinda looks like a mess, and I invented some syntax, but bear with me.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s define an iterator, &lt;code&gt;Fib&lt;&#x2F;code&gt;, that we can use to calculate the fibonacci sequence:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;type Fib = ()
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;impl Iter (Nat, Nat) Nat for Fib = Fib -&amp;gt; Iter {
&lt;&#x2F;span&gt;&lt;span&gt;    state: (0, 1),
&lt;&#x2F;span&gt;&lt;span&gt;    _next: (a, b) -&amp;gt; Some ((a + b, a), a),
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So our internal &lt;code&gt;State&lt;&#x2F;code&gt; is a pair of numbers &lt;code&gt;(Nat, Nat)&lt;&#x2F;code&gt;, and at each iteration we produce an &lt;code&gt;Item&lt;&#x2F;code&gt;, which is a number &lt;code&gt;Nat&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say we define a function that takes an &lt;code&gt;Iter&lt;&#x2F;code&gt;, and prints out all its elements:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_all_iter = (iter: Iter) -&amp;gt; match (next iter) {
&lt;&#x2F;span&gt;&lt;span&gt;    None -&amp;gt; None,
&lt;&#x2F;span&gt;&lt;span&gt;    Some (new_iter, item) -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        println item
&lt;&#x2F;span&gt;&lt;span&gt;        print_all_iter new_iter
&lt;&#x2F;span&gt;&lt;span&gt;    },
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Printing out all the fibonacci numbers (warning!) is as easy as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_all_iter (Iter (Fib ()))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which we can write using &lt;code&gt;|&amp;gt;&lt;&#x2F;code&gt; notation as follows:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Fib () |&amp;gt; Iter |&amp;gt; println_all_iter
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h1 id=&quot;some-sugar&quot;&gt;Some sugar!&lt;&#x2F;h1&gt;
&lt;p&gt;Converting a &lt;code&gt;Wizard&lt;&#x2F;code&gt; to a &lt;code&gt;Person&lt;&#x2F;code&gt; is all well and good, but what if we just want a &lt;code&gt;Wizard&lt;&#x2F;code&gt;’s age? Currently, you’d have to do something like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;(Person merlin).age
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which isn’t that bad. But what if we made &lt;code&gt;Type.field&lt;&#x2F;code&gt; sugar for &lt;code&gt;object -&amp;gt; (Type object).field&lt;&#x2F;code&gt;? Then the above would be:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Person.age merlin
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;which is reminiscent of a uniform function call syntax (UFCS), used to disambiguate when multiple traits are present.&lt;&#x2F;p&gt;
&lt;p&gt;Speaking of multiple traits…&lt;&#x2F;p&gt;
&lt;h1 id=&quot;disambiguating-multiple-traits&quot;&gt;Disambiguating Multiple Traits&lt;&#x2F;h1&gt;
&lt;p&gt;Currently, our functions can really only operate on one trait at a time. If our function accepts an &lt;code&gt;Iterator&lt;&#x2F;code&gt;, we can’t also specify that that type also implements the trait &lt;code&gt;Length&lt;&#x2F;code&gt;. Let’s take a second to flesh out this line of reasoning.&lt;&#x2F;p&gt;
&lt;p&gt;So we have two traits:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;type Iterator = ... -- see previous definition
&lt;&#x2F;span&gt;&lt;span&gt;type Length   = Nat -- the length of a collection
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We can implement both &lt;code&gt;Iterator&lt;&#x2F;code&gt; and &lt;code&gt;Length&lt;&#x2F;code&gt; from a list &lt;code&gt;[T]&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;all T -&amp;gt; impl Iterator Nat T from [T] 
&lt;&#x2F;span&gt;&lt;span&gt;= list -&amp;gt; Iterator {
&lt;&#x2F;span&gt;&lt;span&gt;    state: 0
&lt;&#x2F;span&gt;&lt;span&gt;    _next: index -&amp;gt; if (list.length == index) {
&lt;&#x2F;span&gt;&lt;span&gt;        None
&lt;&#x2F;span&gt;&lt;span&gt;    } else {
&lt;&#x2F;span&gt;&lt;span&gt;        Some (index + 1)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;all T -&amp;gt; impl Length from [T] = list -&amp;gt; list.length
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let’s say we’re writing a function that takes an &lt;code&gt;Iterator&lt;&#x2F;code&gt; it needs to know the &lt;code&gt;Length&lt;&#x2F;code&gt; of. We &lt;em&gt;could&lt;&#x2F;em&gt; require the function to take both separately:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half = iter length -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    for _ in (length &#x2F; 2) {
&lt;&#x2F;span&gt;&lt;span&gt;        (iter, item) = next iter |&amp;gt; unwrap
&lt;&#x2F;span&gt;&lt;span&gt;        println item
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But this is bad because there’s no &lt;em&gt;requirement&lt;&#x2F;em&gt; that &lt;code&gt;length&lt;&#x2F;code&gt; is actually the length of &lt;code&gt;iter&lt;&#x2F;code&gt;. If we pass in an incorrect length, we could cause &lt;code&gt;println_half&lt;&#x2F;code&gt; to &lt;code&gt;unwrap&lt;&#x2F;code&gt; a &lt;code&gt;None&lt;&#x2F;code&gt; value! Aaaaaah!&lt;&#x2F;p&gt;
&lt;p&gt;Ideally, we’d want to be able to specify that &lt;code&gt;iter&lt;&#x2F;code&gt; implements both &lt;code&gt;Iterator&lt;&#x2F;code&gt; and &lt;code&gt;Length&lt;&#x2F;code&gt;. Let’s start by writing out the type of &lt;code&gt;println_half&lt;&#x2F;code&gt; as-is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half : all S I 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Iterator S I 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; Nat 
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;One step we could take is just passing &lt;code&gt;iter&lt;&#x2F;code&gt; to &lt;code&gt;println_half&lt;&#x2F;code&gt; &lt;em&gt;twice&lt;&#x2F;em&gt;, and then constructing &lt;code&gt;Length&lt;&#x2F;code&gt; and &lt;code&gt;Iterator&lt;&#x2F;code&gt; once inside the function:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half = list -&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    iter   = Iter list
&lt;&#x2F;span&gt;&lt;span&gt;    length = Length list
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    for _ in (length &#x2F; 2) {
&lt;&#x2F;span&gt;&lt;span&gt;        (iter, item) = next iter |&amp;gt; unwrap
&lt;&#x2F;span&gt;&lt;span&gt;        println item
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we were to write this as a type, we’d need some way to say that &lt;code&gt;iter&lt;&#x2F;code&gt; implements &lt;em&gt;both&lt;&#x2F;em&gt; &lt;code&gt;Iterator&lt;&#x2F;code&gt; and &lt;code&gt;Length&lt;&#x2F;code&gt;. What would this type &lt;code&gt;???&lt;&#x2F;code&gt; be?&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half : all S I
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ???
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Rust already has a solution for this; it’s to use &lt;code&gt;+&lt;&#x2F;code&gt; to constrain a generic type to a trait:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;println_half&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T, U: Iterator&amp;lt;Item=T&amp;gt; + Length&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span&gt;: U) -&amp;gt; { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here &lt;code&gt;U&lt;&#x2F;code&gt; represents a type that is both an &lt;code&gt;Iterator&lt;&#x2F;code&gt; and has a &lt;code&gt;Length&lt;&#x2F;code&gt;. I feel like we could adopt something like this for Passerine wholesale, but as Passerine’s generic story isn’t that strong yet (heck, I haven’t even decided on a syntax!), I wouldn’t want to overstretch the language in this manner.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I have been working on, though, are type sets, in relation to Passerine’s effect system.&lt;&#x2F;p&gt;
&lt;p&gt;I’m not going to go into too much depth here, but for those familiar, under an effect system, functions may produce a set of side effects:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;print_random_number: () -&amp;gt; {Console, Random} () {
&lt;&#x2F;span&gt;&lt;span&gt;    random_number ()
&lt;&#x2F;span&gt;&lt;span&gt;    |&amp;gt; to_string
&lt;&#x2F;span&gt;&lt;span&gt;    |&amp;gt; println
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So &lt;code&gt;{Console, Random}&lt;&#x2F;code&gt; represents what side effects &lt;code&gt;print_random_number&lt;&#x2F;code&gt; causes. Because this is an effect &lt;em&gt;set&lt;&#x2F;em&gt;, &lt;code&gt;{A, B}&lt;&#x2F;code&gt;, is equivalent to &lt;code&gt;{B, A}&lt;&#x2F;code&gt;, and so on.&lt;&#x2F;p&gt;
&lt;p&gt;A &lt;em&gt;type set&lt;&#x2F;em&gt; could be a generalization of this to types. It’s the set of possible types another type implements as a trait. The type set of something that is iterable and has a length is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;{Iterator, Length}
&lt;&#x2F;span&gt;&lt;span&gt;-- leaving out the generics
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which means we can treat anything of that type as both an &lt;code&gt;Iterator&lt;&#x2F;code&gt; and a &lt;code&gt;Length&lt;&#x2F;code&gt;, using a UFCS-like syntax (sugar) to disambiguate when necessary, as shown above.&lt;&#x2F;p&gt;
&lt;p&gt;So we could write the type of this updated &lt;code&gt;println_half&lt;&#x2F;code&gt; as follows:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;println_half : all S I
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; {Iterator S I, Length}
&lt;&#x2F;span&gt;&lt;span&gt;    -&amp;gt; ()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which I think is fairly clean.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;something-deeper&quot;&gt;Something deeper?&lt;&#x2F;h1&gt;
&lt;p&gt;I think that this relationship between traits and algebraic effects is interesting. It’s something I’ve discussed with others in the past, and it’s something I’d like to continue to explore in the future.&lt;&#x2F;p&gt;
&lt;p&gt;When you think about it, effects are really just dynamically scoped traits; traits whose implementations change depending on dynamic, as opposed to lexically-resolved nominal, scope.&lt;&#x2F;p&gt;
&lt;p&gt;If Rust implemented algebraic effects, would they use &lt;code&gt;+&lt;&#x2F;code&gt; (as discussed earlier) and look like, well, traits? Makes me wonder…&lt;&#x2F;p&gt;
&lt;p&gt;I feel like there’s something deeper here. In essence, our trait system has boiled down to dynamic dispatch over conversion between types.&lt;&#x2F;p&gt;
&lt;p&gt;If I wanted a real trait system, I’d probably adopt HKTs and typeclasses. But part of designing a programming language is choosing a limiting set of axioms, and I think that having a separate language for type-level programming goes against Passerine’s design, which boils down to a functional scripting language. I’m already worried that typechecking will make Passerine take too long to compile; my goal is to have startup times as fast as something like Python.&lt;&#x2F;p&gt;
&lt;p&gt;I know that what I’ve been getting at — representing typeclasses as explicit datastructures — is nothing new, and has been common in both languages without higher-kinded types (such as F#, to get around limitations in the language), and languages with higher-kinded types (such as Agda, where types are just objects, so why couldn’t they be represented as ‘plain datastructures’?).&lt;&#x2F;p&gt;
&lt;p&gt;I feel like all languages in this area are slowly tending towards Agda. Then again, a while back it seemed like everything tended towards Scheme, so maybe it’s just a matter of perspective.&lt;&#x2F;p&gt;
&lt;p&gt;Anyway, I digress. I hope you found this little post interesting, thanks for reading!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;one-last-note&quot;&gt;One last note&lt;&#x2F;h1&gt;
&lt;p&gt;I’ve noticed something interesting. When dealing with closed enumerations, we allow users of that closed enumeration to see any of the members that constitute that enumeration:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;TrafficLight &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    Red,
&lt;&#x2F;span&gt;&lt;span&gt;    Yellow,
&lt;&#x2F;span&gt;&lt;span&gt;    Green,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When we match of traffic light, we can be sure to handle every pattern:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span&gt;use TrafficLight::*;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        Red =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;red&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Yellow =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;yellow&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        Green =&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;green&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }.to_string()
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I want you to stop for a second an just realize that each match branch is a bit like a function. For example, the first branch takes an object of type &lt;code&gt;TrafficLight::Red&lt;&#x2F;code&gt; and returns a static string (&lt;code&gt;&amp;amp;&#x27;static str&lt;&#x2F;code&gt;). We could write this type out as:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;TrafficLight::Red -&amp;gt; &amp;amp;&amp;#39;static str
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So each match branch is really like a function, a closure. “Take the type that matches this pattern, produce this result”. Note that all match arms produce a result of the same type, so a &lt;code&gt;match&lt;&#x2F;code&gt; expression is a bit like a fan-out that compresses each possible branch into a single value.&lt;&#x2F;p&gt;
&lt;p&gt;So why do I bring this up now? Well, when you’re using an open enumeration, like a trait, &lt;em&gt;you can’t possibly know all the types that a value could be&lt;&#x2F;em&gt;. Behind the scenes, though, there’s still a massive match expression.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;&#x2F;&#x2F; `Named` trait
&lt;&#x2F;span&gt;&lt;span&gt;match type {
&lt;&#x2F;span&gt;&lt;span&gt;    Person =&amp;gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;    Wizard =&amp;gt; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So when we implement a trait for yet another type, we’re really just adding another branch to the behind-the-scenes match expression. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Named for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;TrafficLight &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; String {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The method &lt;code&gt;name&lt;&#x2F;code&gt; is just a function of type &lt;code&gt;TrafficLight -&amp;gt; String&lt;&#x2F;code&gt;. Note the parallels here!&lt;&#x2F;p&gt;
&lt;p&gt;Under closed enumeration, we declare all the potential types (i.e. variants) up-front, and then match on these variants to extract common structure&#x2F;behavior:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; infinite number of behaviors
&lt;&#x2F;span&gt;&lt;span&gt;behavior = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; Closed {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; finite number of variants
&lt;&#x2F;span&gt;&lt;span&gt;    Variant -&amp;gt; Dispatch,
&lt;&#x2F;span&gt;&lt;span&gt;    Variant -&amp;gt; Dispatch,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;But under an open enumeration, there are possibly an infinite number of variants! So we declare all possible behaviors up front:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; infinite number of variants
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;trait &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Open &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; finite number of behaviors
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;behavior&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Dispatch;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Whenever we want to add a &lt;code&gt;Variant&lt;&#x2F;code&gt; to &lt;code&gt;Open&lt;&#x2F;code&gt;, we have to provide a match arm for each ‘behind-the-scenes’ &lt;code&gt;behavior&lt;&#x2F;code&gt; match expression:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;Rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-Rust &quot;&gt;&lt;code class=&quot;language-Rust&quot; data-lang=&quot;Rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Open for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Variant &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; This is just a match arm!
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;behavior&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Dispatch { 
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So for each &lt;code&gt;behavior&lt;&#x2F;code&gt; in the &lt;code&gt;Open&lt;&#x2F;code&gt; enumeration, we provide a match arm: &lt;code&gt;Variant -&amp;gt; Dispatch&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;The compiler stitches all these disparate match arms together to form these behind the scene match expressions:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; finite number of behaviors
&lt;&#x2F;span&gt;&lt;span&gt;behavior = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; Open {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; infinite number of variants
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Open for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;Variant&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;impl Open for Variant&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each implementation is like an opaque match arm.&lt;&#x2F;p&gt;
&lt;p&gt;To summarize:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Under closed enumerations, we have a finite number of variant branches; we must handle each branch while being able to implement arbitrarily many behaviors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Under open enumerations, we have an infinite number of possible variant branches; to add a new variant, we must provide the ‘match-arms’ for a finite number of behaviors.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Now because open enumerations are defined around a finite set of behaviors, it makes sense that each variant &lt;em&gt;must&lt;&#x2F;em&gt; provide a function.&lt;&#x2F;p&gt;
&lt;p&gt;It is simply not possible to have both an infinite number of behaviors and an infinite number of variants. You can pick one or the other, and the structure of the resulting code will be affected by that decision.&lt;&#x2F;p&gt;
&lt;p&gt;I just love this parallel, and think that it drastically simplified my mental model of traits vs enums.&lt;&#x2F;p&gt;
&lt;p&gt;Traits as implicit conversion is essentially makes types open enumerations over the behavior of their constructor function. This model is really elegant because it reifies types and traits (we’re not ‘adding an extra layer’ to the language), but on the other hand it does complicate things somewhat.&lt;&#x2F;p&gt;
&lt;p&gt;I think this is honestly the pain of being a language designer. You get a &lt;em&gt;feeling&lt;&#x2F;em&gt; that there are these fundamental underlying constructs that underpin the way the world works. You spend a lot of time refining these feelings—writing them down, building prototypes—only to realize that everything old is new again, or that there are new cases you haven’t thought about that don’t neatly fit your model.&lt;&#x2F;p&gt;
&lt;p&gt;I wish there was just &lt;em&gt;a&lt;&#x2F;em&gt; language, a silver bullet, where these sorts of tradeoffs didn’t exist. A language where there was one single &lt;em&gt;obvious&lt;&#x2F;em&gt; way to implement something. A language where all semantic symmetries were wrapped up in symmetrical syntax, all constructs discovered through intuitive exploration and composition.&lt;&#x2F;p&gt;
&lt;p&gt;I know that this youthful idealism is unwarranted. The rubber has to hit the road somewhere, tradeoffs will always exist, and software is never developed alone. We need a Go of functional programming, whatever what that ends up looking like: a smaller Rust, a minimal Agda, a typed Scheme.&lt;&#x2F;p&gt;
&lt;p&gt;I can’t claim that Passerine will be that language. I’ve worked hard to engineer a minimal set of orthogonal features that &lt;em&gt;compose&lt;&#x2F;em&gt;. Once I’ve figured out how to unify effects and fibers (it’s mostly a matter of notation at this point), and have more cleanly delineated the line between the macro system and the type system, I think I may have an unstoppable seed of a language on my hands.&lt;&#x2F;p&gt;
&lt;p&gt;We’ll see where it goes from here :)&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Sketchnoting: a spontaneous but needed reflection</title>
        <published>2022-02-11T00:00:00+00:00</published>
        <updated>2022-02-11T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/note/"/>
        <id>https://slightknack.dev/blog/note/</id>
        
        <summary type="html">&lt;h1 id=&quot;preface&quot;&gt;Preface&lt;&#x2F;h1&gt;
&lt;p&gt;Since September of last year, I’ve been chipping away at a long-form post on how to take &lt;em&gt;good&lt;&#x2F;em&gt; notes. This, sadly, is not that post—consider this post a teaser to tide you over until then.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;note-vols.jpg&quot; alt=&quot;Four filled notebooks and one new empty one.&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Today I finished my fourth book of sketchnotes. Each book has about 240 blank A5 pages, so I guess I’m fast-approaching the thousand-page mark. In celebration of filling yet another volume, I took a trip down memory lane and dug out &lt;em&gt;Volumes 1-3&lt;&#x2F;em&gt;. Taking the time to read through some of my older notes, it’s easy to see that I’ve improved quite a lot.&lt;&#x2F;p&gt;
&lt;p&gt;While reading through my second notebook, though, I found a short hand-written collection of my thoughts on note-taking. Although it’s been a few years since then, I feel like the core of what I had to say then rings true today.&lt;&#x2F;p&gt;
&lt;p&gt;Below I’ve typed up those few pages of notes, I hope you find them interesting:&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Predicting the technology of 2027</title>
        <published>2022-01-04T00:00:00+00:00</published>
        <updated>2022-01-04T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/2027/"/>
        <id>https://slightknack.dev/blog/2027/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/2027/">&lt;p&gt;The other day, I was thinking about this question:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;What’s something that is not common today that you think will be really common 5 years from now?&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;As I do a lot of programming language design, I can’t help but think about what our tooling will be like in 5 years. I’m writing this in 2022, so here are some of my predictions for 2027, in no particular order:&lt;&#x2F;p&gt;
&lt;h1 id=&quot;copilot-co&quot;&gt;Copilot &amp;amp; co.&lt;&#x2F;h1&gt;
&lt;p&gt;First things first, although I strongly dislike (and don’t use) copilot, I think that AI-based code completion tools will become more and more common to the point of being indispensable. Recent advances in large language models reduce the attention complexity from &lt;code&gt;n²&lt;&#x2F;code&gt; to &lt;code&gt;n&lt;&#x2F;code&gt;, which means we’ll be seeing larger attention windows, and hence more concise code generation.&lt;&#x2F;p&gt;
&lt;p&gt;Additionally, work from Google on query-based models (models that have an external database) will be put to use, allowing for correct attribution as to where the model is generating its completion from, more up-to-date completions (model doesn’t have to be retrained, only database has to be updated), and more specific completions (using current codebase as database).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;structured-tooling&quot;&gt;Structured Tooling&lt;&#x2F;h1&gt;
&lt;p&gt;With the rise of JetBrains, Tree-Sitter, and languages like Unison, I believe we’ll see more structured tooling; instead of modifying text, we’ll be working on entire ASTs. editors already do this to some degree, with completion, automatic bracket insertion, and indentation preservation, but I think tools for automatic semantic refactoring will become more prevalent. For this to happen I estimate that either a new plugin, editor, or LSP will be developed with support for all major languages.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;effects&quot;&gt;Effects&lt;&#x2F;h1&gt;
&lt;p&gt;Language-wise, there are some exciting features I see coming soon to a Language Near You™. The first one being a move towards algebraic effects for effect modeling. It turns out that a lot of language features—like control flow, concurrency, async&#x2F;await, yielding, exceptions, etc.—can be modeled in terms of effects. There’s a lot of potential here, and I think that either through libraries or (hopefully) language-level support, they’ll become more prevalent.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;gradual-typing&quot;&gt;Gradual Typing&lt;&#x2F;h1&gt;
&lt;p&gt;Noting the rise of TypeScript, I think we’ll also see the move towards languages that allow people to specify correctness in their programs over time. Functions can be written purely dynamically, like python, but over time type annotations can be added until you end up with strongly-typed programs a la Haskell.&lt;&#x2F;p&gt;
&lt;p&gt;Once a program is fully typed, there may be additional tools to prove the correctness of parts of a program. I don’t think this will be mainstream, but I think within 5 years tools like this will become more common and more ergonomic than they are today.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;machine-reinforcement-learning&quot;&gt;Machine&#x2F;Reinforcement Learning&lt;&#x2F;h1&gt;
&lt;p&gt;Aside from languages and tooling, I’d like to make some predictions within the field of ML. I predict we’ll see the creation of a language model that achieves above-human-expert performance on a number of text-based tasks. Some will say AI has passed human intelligence, others will say it’s only expert in a narrow context. Either way, they’re both forgetting that ‘AI’ will always be whatever humans &lt;em&gt;can&lt;&#x2F;em&gt; do that machines can &lt;em&gt;not&lt;&#x2F;em&gt; do yet.&lt;&#x2F;p&gt;
&lt;p&gt;I also think we’ll see the rise of more accurate and less data-intensive RL techniques that rely on attention-based trajectory prediction rather than PPO-like policy optimization. TL;DR is that we’ll become better at training models on tasks with low data availability for general optimization. Sadly, I think ML is moving away from open-source, and I think that most production models will be released as a blogpost + API instead of paper + code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;games-raytracing-vr&quot;&gt;Games, Raytracing, VR&lt;&#x2F;h1&gt;
&lt;p&gt;With respect to games and graphics, real-time raytracing will become the norm. Aside from the increase in realism in games, as photorealism becomes more realistic, we’ll also see the move towards selective and stylistic games that use raytracing and PBR techniques to strongly enforce a non-PBR-like style. Real-time style transfer at high-resolutions may play an important role in this.&lt;&#x2F;p&gt;
&lt;p&gt;Oculus outsold XBox this year, which means that VR will become a lot bigger; your favorite VR game probably hasn’t been created yet. I generally dislike VR, but the technology is becoming a lot better. I just pray that the zuckerbergian dystopian metaverse doesn’t come to fruition and is usurped by a wider open-source protocol.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;&#x2F;h1&gt;
&lt;p&gt;I tried to be both optimistic yet honest in my above predictions. I don’t think there’s anything too surprising there for anyone entrenched in the field, but I’d really like to see how spot-on I was 5 years from now. Hey, maybe this’ll be a self-fulfilling prophecy.&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Using Proof-of-Work to Manage Backpressure</title>
        <published>2021-12-01T00:00:00+00:00</published>
        <updated>2021-12-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/dynamic-pow-backpressure/"/>
        <id>https://slightknack.dev/blog/dynamic-pow-backpressure/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/dynamic-pow-backpressure/">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;&#x2F;strong&gt; This is a quick piece that assumes some prior knowledge of PoW and backpressure. If you want to build up an intuition about backpressure before jumping in, you could read &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@jayphelps&#x2F;backpressure-explained-the-flow-of-data-through-software-2350b3e77ce7&quot;&gt;&lt;em&gt;this piece&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; or &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.tedinski.com&#x2F;2019&#x2F;03&#x2F;05&#x2F;backpressure.html&quot;&gt;&lt;em&gt;that one&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;. If you’d like to learn more about PoW in the context of this article, check out &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Hashcash&quot;&gt;&lt;em&gt;this article&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; (and &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Proof_of_work&quot;&gt;&lt;em&gt;that one as well&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;).&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;On the bus this afternoon, I was reading up on backpressure in distributed systems. Backpressure, long story short, is the backward force acting on data as it moves through a system.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;what-s-backpressure&quot;&gt;What’s Backpressure?&lt;&#x2F;h1&gt;
&lt;p&gt;Maintaining a healthy level of backpressure is important for creating a well-running system monolithic, microservice, distributed, or otherwise. Too little backpressure and services will be spending time idle waiting for work to arrive. Too much backpressure, on the other hand, can lead to a buildup of work and fatal system resets.&lt;&#x2F;p&gt;
&lt;p&gt;One of the first mistakes I made when first building distributed systems was not paying attention to the backpressure bottlenecks of the system. Although there are many ways to classify, manage, and build systems that main consistent backpressure, one system I want to focus on is proof-of-work based rate limiting.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;proof-of-work&quot;&gt;Proof of Work&lt;&#x2F;h1&gt;
&lt;p&gt;Proof-of-work (PoW) is nothing new. Now primarily associated with consensus mechanisms used BitCoin et al., PoW was first used an obscure email tool used to rate-limit spam and DoS attacks. In no small part due to the popularity of BitCoin, PoW has found a number of other uses.&lt;&#x2F;p&gt;
&lt;p&gt;I was prompted to write this post after re-reading the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;pest.bitdash.io&#x2F;whitepaper.html&quot;&gt;Pest&lt;&#x2F;a&gt; specification, a distributed IRC-like protocol that uses PoW to maintain a steady influx of messages.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;managing-backpressure&quot;&gt;Managing Backpressure&lt;&#x2F;h1&gt;
&lt;p&gt;When managing backpressure, there are essentially two things that can be going wrong:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;You’re not receiving enough messages, meaning there’s probably a &lt;em&gt;bottleneck&lt;&#x2F;em&gt; somewhere else in the system.&lt;&#x2F;li&gt;
&lt;li&gt;You’re receiving too many messages, meaning &lt;em&gt;you’re&lt;&#x2F;em&gt; probably the bottleneck in the system.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;It’s important to remember that not all messages sent in a distributed system are necessary for the healthy operation of the system. When a service gets too stressed, services calling that service can reduce the number of messages they’re sending to improve the latency of the system (while maintaining consistent throughput).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;pow-and-backpressure&quot;&gt;PoW and Backpressure&lt;&#x2F;h1&gt;
&lt;p&gt;The PoW Backpressure scheme I propose is pretty simple. Whenever a node—let’s call it the &lt;em&gt;client&lt;&#x2F;em&gt;—establishes a connection with a service it relies on—the &lt;em&gt;server&lt;&#x2F;em&gt;—the server returns a nonce and a work level for use in the next request. We’ll call this the &lt;em&gt;challenge&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;nonce&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;C9B76FBD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;work&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;:  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;To make a request, the client must complete the challenge. To do so, it must calculate the hash of the request it wants to send, append the nonce, and compute &lt;code&gt;N&lt;&#x2F;code&gt; rounds of proof of work (e.g. repeated hashing) until the specified work level has been met. The response and corresponding &lt;em&gt;proof&lt;&#x2F;em&gt; are then sent to the server for processing:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;json&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-json &quot;&gt;&lt;code class=&quot;language-json&quot; data-lang=&quot;json&quot;&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;nonce&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;C9B76FBD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;N&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;:     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;456&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;req&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;:   { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;...&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot; &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;PoW proofs are cheap to verify. If the server tries to validate the PoW and finds it to be invalid (incorrect &lt;code&gt;nonce&lt;&#x2F;code&gt; or incorrect &lt;code&gt;N&lt;&#x2F;code&gt;), it simply drops the message. If the proof is valid, however, the server unwraps the inner request &lt;code&gt;req&lt;&#x2F;code&gt; from the client and processes it as usual.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Aside:&lt;&#x2F;strong&gt; Whenever the server receives a message, it should &lt;em&gt;immediately&lt;&#x2F;em&gt; send a new challenge to the client.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Proof-of-work acts as a natural rate limiter of requests. It requires the client to do the bulk of the work creating a valid request. This is especially important in the context of untrusted distributed contexts, where it is easy to increase the work attackers need to perform without impacting the work the server needs to do to validate correctly formed packets.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;adjusting-the-rate-limit&quot;&gt;Adjusting the rate limit&lt;&#x2F;h1&gt;
&lt;p&gt;In the last section, we know how PoW can act as a rate limit. In this section I want to talk about adjusting that rate limit.&lt;&#x2F;p&gt;
&lt;p&gt;When the backpressure is too low, the work limit should be decreased; when it is to high, it should be increased. Say we have a queue of unprocessed requests &lt;code&gt;B&lt;&#x2F;code&gt;. We can set the backpressure as a function of the length of &lt;code&gt;B&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;Each successive work factor is twice as hard as the previous one: &lt;code&gt;2&lt;&#x2F;code&gt; is twice as much work as &lt;code&gt;1&lt;&#x2F;code&gt;, just as &lt;code&gt;11&lt;&#x2F;code&gt; is twice as much work as &lt;code&gt;10&lt;&#x2F;code&gt;. We can quantify the rate of incoming messages as:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;incoming &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;network_capacity &lt;&#x2F;span&gt;&lt;span&gt;* (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;^ -&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So at a rate of &lt;code&gt;1000&lt;&#x2F;code&gt; messages per second when the work factor is &lt;code&gt;0&lt;&#x2F;code&gt;, changing the work factor to &lt;code&gt;3&lt;&#x2F;code&gt; would change the rate of incoming messages to &lt;code&gt;1000 * (1&#x2F;8)&lt;&#x2F;code&gt;, or &lt;code&gt;125&lt;&#x2F;code&gt;, messages per second.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say we want to maintain a backpressure of &lt;code&gt;K&lt;&#x2F;code&gt; items in queue &lt;code&gt;B&lt;&#x2F;code&gt;, out of the length of our queue, &lt;code&gt;len(B)&lt;&#x2F;code&gt;. We know we can send &lt;code&gt;outgoing&lt;&#x2F;code&gt; messages per second, and can estimate the network capacity given the current work factor. To calculate the work factor we want to set, we could use something like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;network_capacity &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;outgoing&lt;&#x2F;span&gt;&lt;span&gt;) * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;K&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This equation will try to match the throughput of the input, times some adjustment used to maintain constant backpressure. Let’s try out an example.&lt;&#x2F;p&gt;
&lt;p&gt;Let’s say we’re receiving &lt;code&gt;1000&lt;&#x2F;code&gt; messages per second, we want &lt;code&gt;100&lt;&#x2F;code&gt; in queue, and we process &lt;code&gt;200&lt;&#x2F;code&gt; per second. Our queue currently has &lt;code&gt;800&lt;&#x2F;code&gt; messages in it. What should we set our work factor to be?&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;network_capacity &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;outgoing&lt;&#x2F;span&gt;&lt;span&gt;) * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;B&lt;&#x2F;span&gt;&lt;span&gt;) &#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;K&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;200     &lt;&#x2F;span&gt;&lt;span&gt;) * (   &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;800 &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;))
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;40&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;5.32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; rounded
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Once the target backpressure is restored, this work factor will decrease until a steady state is reached. Once the state is reached (i.e. &lt;code&gt;len(B) == K&lt;&#x2F;code&gt;), in the above example, the work factor will decrease to &lt;code&gt;2&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;1000 &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;200&lt;&#x2F;span&gt;&lt;span&gt;) * (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;100 &lt;&#x2F;span&gt;&lt;span&gt;&#x2F; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;100&lt;&#x2F;span&gt;&lt;span&gt;)) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; len(B) == K
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;log_2&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2.32
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;work_factor &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; rounded
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This work factor is quick to calculate and will adjust to automatically. For &lt;em&gt;servers&lt;&#x2F;em&gt; that can scale horizontally, it can also be a good metric as to when to spin up more instances (if you want to maintain low latency without rate limiting your users).&lt;&#x2F;p&gt;
&lt;h1 id=&quot;dynamic-rate-limiting&quot;&gt;Dynamic Rate Limiting&lt;&#x2F;h1&gt;
&lt;p&gt;There is nothing that requires that PoW be universal across all clients. Servers can be selective and choose to increase work for IPs exhibiting DoS-like behavior, clients sending too many messages, or untrusted clients in a distributed network.&lt;&#x2F;p&gt;
&lt;p&gt;There’s a lot more that can be explored now, but it’s getting late and I value my sleep. :P&lt;&#x2F;p&gt;
&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;&#x2F;h1&gt;
&lt;p&gt;I hope you’ve found this little piece interesting. If you’re ever dealing with managing backpressure, I hope that you’ll find PoW-based rate limiting to be a useful tool in your toolbox. Until next time!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Thinking about efficient backing stores for CRDTs</title>
        <published>2021-08-02T00:00:00+00:00</published>
        <updated>2021-08-02T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/backing-crdt-store/"/>
        <id>https://slightknack.dev/blog/backing-crdt-store/</id>
        
        <summary type="html">&lt;p&gt;A &lt;em&gt;Conflict-Free Replicated Datatype&lt;&#x2F;em&gt; is a bit like a smoothie: the same ingredients will produce the same result, regardless of the order in which they are added. In the context of, say, text editing in a distributed context, merging two documents will always succeed in a deterministic manner. In other words, A CRDT is a bit like a git repository that never has merge conflicts.&lt;&#x2F;p&gt;
&lt;p&gt;There are many different ways to approach the construction of CRDTs, each construction having its own strengths and weaknesses. Today, we’re going to focus on creating out an efficient backing store for a particular family of algorithms known as &lt;em&gt;Replicated Growth Arrays&lt;&#x2F;em&gt; (RGA).&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Getting bindgen working on NixOS</title>
        <published>2021-07-08T00:00:00+00:00</published>
        <updated>2021-07-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/nix-os-bindgen/"/>
        <id>https://slightknack.dev/blog/nix-os-bindgen/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/nix-os-bindgen/">&lt;blockquote&gt;
&lt;h1 id=&quot;note&quot;&gt;Note&lt;&#x2F;h1&gt;
&lt;p&gt;this is a collection of a set of discord messages sent on the NixOS discord server.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h1 id=&quot;troubles-w-nixos&quot;&gt;Troubles w&#x2F; NixOS&lt;&#x2F;h1&gt;
&lt;p&gt;I’m back! This is a hard one, I swear, and I’ve been banging my head against it for hours: I’m trying to compile a rust library that wraps &lt;code&gt;libcec&lt;&#x2F;code&gt;. To wrap &lt;code&gt;libc&lt;&#x2F;code&gt;, this library uses &lt;code&gt;bindgen&lt;&#x2F;code&gt;. Here’s what the crate roughly looks like:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;.
&lt;&#x2F;span&gt;&lt;span&gt;├── build.rs
&lt;&#x2F;span&gt;&lt;span&gt;├── Cargo.toml
&lt;&#x2F;span&gt;&lt;span&gt;└── src
&lt;&#x2F;span&gt;&lt;span&gt;    ├── lib.rs
&lt;&#x2F;span&gt;&lt;span&gt;    └── wrapper.h
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Two important things to note: &lt;code&gt;build.rs&lt;&#x2F;code&gt; invokes bindgen, doing something like the following:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bindgen::Builder::default()
&lt;&#x2F;span&gt;&lt;span&gt;    .header(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;src&#x2F;wrapper.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;    .generate()
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And &lt;code&gt;wrapper.h&lt;&#x2F;code&gt; is just a simple header that includes &lt;code&gt;libcec&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;libcec&#x2F;cecc.h&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;On most operating systems, clang or whatever leafs through well-known &lt;code&gt;include&lt;&#x2F;code&gt; locations to toss together a big ol’ binary salad. NixOS, of course, loathes this. So, upon trying to compile this crate via &lt;code&gt;cargo build&lt;&#x2F;code&gt;, we get an error, sensibly enough:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;src&#x2F;wrapper.h:1:10: fatal error: &amp;#39;libcec&#x2F;cecc.h&amp;#39; file not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;No problemo! We can use &lt;code&gt;.clang_arg(...)&lt;&#x2F;code&gt; to send clang some args about where to look for &lt;code&gt;include&lt;&#x2F;code&gt; locations. Here’s an example that works with macOS, say:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;bindgen::Builder::default()
&lt;&#x2F;span&gt;&lt;span&gt;    .header(&amp;quot;src&#x2F;wrapper.h&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    .clang_arg(&amp;quot;-I&#x2F;usr&#x2F;local&#x2F;include&amp;quot;)
&lt;&#x2F;span&gt;&lt;span&gt;    ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So we just need to find the include location for &lt;code&gt;libcec&lt;&#x2F;code&gt; on NixOS, right? tossing this into our &lt;code&gt;shell.nix&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nix&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-nix &quot;&gt;&lt;code class=&quot;language-nix&quot; data-lang=&quot;nix&quot;&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;LIBCEC_PATH&lt;&#x2F;span&gt;&lt;span&gt;=&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;${&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;libcec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;}&#x2F;include&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We then &lt;em&gt;should&lt;&#x2F;em&gt; be able to specify the right include location:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;.clang_arg(&amp;quot;-I$LIBCEC_PATH&amp;quot;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Huh, this doesn’t work, same error as before:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;src&#x2F;wrapper.h:1:10: fatal error: &amp;#39;libcec&#x2F;cecc.h&amp;#39; file not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Well, we can always just skip the wrapper and pull in the header file directly, right? Let’s echo &lt;code&gt;$LIBCEC_PATH&lt;&#x2F;code&gt; to find where in the heavens above &lt;code&gt;libcec&lt;&#x2F;code&gt; is, locate the header file, then schloop that in:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;$ tree $LIBCEC_PATH
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;nix&#x2F;store&#x2F;klsqc20n71gja5b8sa9ncw1jl6lcaxw9-libcec-6.0.2&#x2F;include
&lt;&#x2F;span&gt;&lt;span&gt;└── libcec
&lt;&#x2F;span&gt;&lt;span&gt;    ├── cecc.h
&lt;&#x2F;span&gt;&lt;span&gt;    └── ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There it is!&lt;&#x2F;p&gt;
&lt;p&gt;I know this isn’t best practice, but let’s use this as the path to the header file we want in &lt;code&gt;build.rs&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;bindgen::Builder::default()
&lt;&#x2F;span&gt;&lt;span&gt;    .header(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&#x2F;nix&#x2F;store&#x2F;klsqc20n71gja5b8sa9ncw1jl6lcaxw9-libcec-6.0.2&#x2F;include&#x2F;libcec&#x2F;cecc.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It’s not the prettiest, but it should work, right? … uh… right… ?&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;$ cargo build
&lt;&#x2F;span&gt;&lt;span&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;&#x2F;nix&#x2F;store&#x2F;klsqc20n71gja5b8sa9ncw1jl6lcaxw9-libcec-6.0.2&#x2F;include&#x2F;libcec&#x2F;cectypes.h:38:10:
&lt;&#x2F;span&gt;&lt;span&gt;fatal error: &amp;#39;stdint.h&amp;#39; file not found
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Drat! Foiled again! It seems NixOS is too clever for me. This time the entirety of &lt;code&gt;libc&lt;&#x2F;code&gt; has gone missing!&lt;&#x2F;p&gt;
&lt;p&gt;At this point, I spent about another few hours trying to get &lt;code&gt;libc&lt;&#x2F;code&gt; to show up. I also read a ton (e.g. &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;nixos.wiki&#x2F;wiki&#x2F;C&quot;&gt;C on Nix wiki&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;gnulib&#x2F;manual&#x2F;html_node&#x2F;stdint_002eh.html&quot;&gt;stdint in gnulibc manual&lt;&#x2F;a&gt;, &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;NixOS&#x2F;nixpkgs&#x2F;issues?q=is%3Aissue+stdint.h+&quot;&gt;NixOS issue related to stdint&lt;&#x2F;a&gt;, etc.) to no avail.&lt;&#x2F;p&gt;
&lt;p&gt;So here’s my question: What am I doing wrong? How can I use &lt;code&gt;bindgen&lt;&#x2F;code&gt; to wrap a c library in a crate? If you need any additional information, ping me and I’ll send it right over! Thank you!&lt;&#x2F;p&gt;
&lt;h1 id=&quot;update-an-incredible-solution&quot;&gt;Update! An incredible solution&lt;&#x2F;h1&gt;
&lt;p&gt;Shortly after I posted this, I reached out to &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;github.com&#x2F;Siraben&quot;&gt;Ben Siraphob&lt;&#x2F;a&gt;, a good friend of mine who convinced me to try out NixOS in the first place. We hopped on a call together, and he showed me how to reach a solution. Credit for the solution goes to him, I was in way over my head!&lt;&#x2F;p&gt;
&lt;p&gt;So, what was the solution, anyway? After searching for similar packages on Nixpkgs, we found that this issue itself was pretty uncommon (go figure). Luckily enough for us, it looked like the derivations of Firefox (I think?) and about two other projects had to deal with linking against evasive c library headers.&lt;&#x2F;p&gt;
&lt;p&gt;The first order of business was switching out &lt;code&gt;shell.nix&lt;&#x2F;code&gt; for a proper derivation. because it’s a Rust project we’re compiling, it’s best to use &lt;code&gt;rustPlatform.buildRustPackage&lt;&#x2F;code&gt;. After declaring the package and including it’s SHA, the first thing we needed to do was make sure &lt;code&gt;LIBCLANG&lt;&#x2F;code&gt; was in the right spot and could be found. This is simple enough:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nix&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-nix &quot;&gt;&lt;code class=&quot;language-nix&quot; data-lang=&quot;nix&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;rustPlatform&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;buildRustPackage &lt;&#x2F;span&gt;&lt;span&gt;rec {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;LIBCLANG_PATH &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;quot;${&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;llvmPackages&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;libclang&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;lib&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;}&#x2F;lib&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;# ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Next thing we needed to do was pass in some c flags to bindgen. I’m not too sure what these do, but they’re what was used by Firefox and they seem to work:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;configurePhase = &amp;#39;&amp;#39;
&lt;&#x2F;span&gt;&lt;span&gt;  BINDGEN_CFLAGS=&amp;quot;$(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;libc-crt1-cflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    $(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;libc-cflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    $(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;cc-cflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    $(&amp;lt; ${stdenv.cc}&#x2F;nix-support&#x2F;libcxx-cxxflags) \
&lt;&#x2F;span&gt;&lt;span&gt;    ${lib.optionalString stdenv.cc.isClang &amp;quot;-idirafter ${stdenv.cc.cc.lib}&#x2F;lib&#x2F;clang&#x2F;${lib.getVersion stdenv.cc.cc}&#x2F;include&amp;quot;} \
&lt;&#x2F;span&gt;&lt;span&gt;    ${lib.optionalString stdenv.cc.isGNU &amp;quot;-isystem ${lib.getDev stdenv.cc.cc}&#x2F;include&#x2F;c++&#x2F;${lib.getVersion stdenv.cc.cc} -isystem ${stdenv.cc.cc}&#x2F;include&#x2F;c++&#x2F;${lib.getVersion stdenv.cc.cc}&#x2F;${stdenv.hostPlatform.config}&amp;quot;} \
&lt;&#x2F;span&gt;&lt;span&gt;    $NIX_CFLAGS_COMPILE&amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;  export OUT=${placeholder &amp;quot;out&amp;quot;}
&lt;&#x2F;span&gt;&lt;span&gt;  echo $OUT
&lt;&#x2F;span&gt;&lt;span&gt;&amp;#39;&amp;#39;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Which is a lot, but it isn’t a lot a lot. But wait! how does Rust know where libcec is during compilation? obviously hardcoding something in the &lt;code&gt;store&lt;&#x2F;code&gt; is a bad idea!&lt;&#x2F;p&gt;
&lt;p&gt;During the patch phase (which happens before the configuration phase seen above), we can perform a substitution. In &lt;code&gt;build.rs&lt;&#x2F;code&gt;, we can switch out the builder to be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; bindings = bindgen::Builder::default()
&lt;&#x2F;span&gt;&lt;span&gt;    .header(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;LIBCEC_HEADERS&#x2F;include&#x2F;libcec&#x2F;cecc.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And then substitute out LIBCEC_HEADERS with the path to the actual headers:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nix&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-nix &quot;&gt;&lt;code class=&quot;language-nix&quot; data-lang=&quot;nix&quot;&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;patchPhase &lt;&#x2F;span&gt;&lt;span&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;#39;&amp;#39;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;  substituteInPlace build.rs --replace &amp;quot;LIBCEC_HEADERS&amp;quot; &amp;quot;${&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;libcec&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;}&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;&amp;#39;&amp;#39;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This seems like a bit of a hack, but hey, at least it works! Last but not least, we can set our build inputs, and…&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;nativeBuildInputs = [
&lt;&#x2F;span&gt;&lt;span&gt;  llvmPackages.clang
&lt;&#x2F;span&gt;&lt;span&gt;  tree
&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;buildInputs = [
&lt;&#x2F;span&gt;&lt;span&gt;  libcec glibc
&lt;&#x2F;span&gt;&lt;span&gt;];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Tada! Everything works as intended! There’s a little cleanup that needs to be done to extract the resulting Rust binary, but I’ll spare you the details.&lt;&#x2F;p&gt;
&lt;p&gt;NixOS is pretty cool, but it seems to be targeted towards people who like to roll their own solutions and stick to open source software. This is great! If you do decide to go all in, though, be prepared!&lt;&#x2F;p&gt;
&lt;p&gt;Thanks again to everyone who helped me resolve this issue! Nix has shown me how many assumptions are present when building modern software, and it’s surprising how good of a job they’ve done categorizing different issues and dependencies and making reproducible builds as easy as &lt;code&gt;nix build&lt;&#x2F;code&gt;. ’Til next time!&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Lenguas del mundo hispánico</title>
        <published>2021-06-09T00:00:00+00:00</published>
        <updated>2021-06-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/gallery/lenguas/"/>
        <id>https://slightknack.dev/gallery/lenguas/</id>
        
        <content type="html" xml:base="https://slightknack.dev/gallery/lenguas/">
&lt;style&gt;
#floating-nav-img {
  vertical-align: middle;
  display: inline-block;
  width: 30pt;
  height: 30pt;
  border-radius: 40pt;
  margin: 0;
  padding: 0;
}

#floating-nav {
  background: var(--fill-bg);
  border-radius: 40pt;
  position: fixed;
  z-index: 999;
  top: 20pt;
  right: 20pt;
  border: 2px solid var(--fill-bg);
}

#floating-nav &gt; .tag {
  display: none
}

#floating-nav:hover &gt; .tag {
  display: initial
}

&lt;&#x2F;style&gt;

&lt;div id=&quot;floating-nav&quot;&gt;
  &lt;span class=&quot;tag&quot; style=&quot;padding-left: 20pt;&quot;&gt;&lt;a href=&quot;&#x2F;&quot;&gt;isaac.sh&lt;&#x2F;a&gt; · &lt;a href=&quot;&#x2F;gallery&quot;&gt;back to Gallery&lt;&#x2F;a&gt; · &lt;&#x2F;span&gt;
  &lt;img id=&quot;floating-nav-img&quot; src=&quot;&#x2F;icon.png&quot;&gt;&lt;&#x2F;img&gt;
&lt;&#x2F;div&gt;
&lt;iframe style=&quot;height: 100vh; width: 100%; margin-bottom: -2vh;&quot; src=&quot;https:&#x2F;&#x2F;www.figma.com&#x2F;embed?embed_host=share&amp;url=https%3A%2F%2Fwww.figma.com%2Fproto%2FE8GflU8DuOPVBDVsNtpfG6%2FInfograf%C3%ADa-Sobre-Idiomas%3Fnode-id%3D1%253A4%26scaling%3Dscale-down-width&quot; allowfullscreen=&quot;&quot;&gt;&lt;&#x2F;iframe&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Shader Portal</title>
        <published>2021-06-09T00:00:00+00:00</published>
        <updated>2021-06-09T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/gallery/portal/"/>
        <id>https://slightknack.dev/gallery/portal/</id>
        
        <content type="html" xml:base="https://slightknack.dev/gallery/portal/">
&lt;style&gt;
#floating-nav-img {
  vertical-align: middle;
  display: inline-block;
  width: 30pt;
  height: 30pt;
  border-radius: 40pt;
  margin: 0;
  padding: 0;
}

#floating-nav {
  background: var(--fill-bg);
  border-radius: 40pt;
  position: fixed;
  z-index: 999;
  top: 20pt;
  right: 20pt;
  border: 2px solid var(--fill-bg);
}

#floating-nav &gt; .tag {
  display: none
}

#floating-nav:hover &gt; .tag {
  display: initial
}

&lt;&#x2F;style&gt;

&lt;div id=&quot;floating-nav&quot;&gt;
  &lt;span class=&quot;tag&quot; style=&quot;padding-left: 20pt;&quot;&gt;&lt;a href=&quot;&#x2F;&quot;&gt;isaac.sh&lt;&#x2F;a&gt; · &lt;a href=&quot;&#x2F;gallery&quot;&gt;back to Gallery&lt;&#x2F;a&gt; · &lt;&#x2F;span&gt;
  &lt;img id=&quot;floating-nav-img&quot; src=&quot;&#x2F;icon.png&quot;&gt;&lt;&#x2F;img&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Macros, Types, and Next Steps</title>
        <published>2021-06-01T00:00:00+00:00</published>
        <updated>2021-06-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/next-steps/"/>
        <id>https://slightknack.dev/passerine/next-steps/</id>
        
        <summary type="html">&lt;p&gt;Passerine is at an interesting point: we’ve established a few language features, and built this easily extensible functional core on which to base the rest of the language. We currently have two implementations of the language, one written in Rust, the other in D, and it’s imperative we set the course of the language before divergence occurs.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Mirror: Hindley Milner Type Inference</title>
        <published>2021-05-01T00:00:00+00:00</published>
        <updated>2021-05-01T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/type-inference/"/>
        <id>https://slightknack.dev/passerine/type-inference/</id>
        
        <content type="html" xml:base="https://slightknack.dev/passerine/type-inference/">&lt;blockquote&gt;
&lt;p&gt;This is a frozen mirror of &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.cs.cornell.edu&#x2F;courses&#x2F;cs3110&#x2F;2016fa&#x2F;l&#x2F;17-inference&#x2F;notes.html&quot;&gt;notes from Cornell’s CS3110&lt;&#x2F;a&gt;. Full disclosure, I did not write this.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;topics&quot;&gt;Topics&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Type inference and reconstruction&lt;&#x2F;li&gt;
&lt;li&gt;Constraint collection&lt;&#x2F;li&gt;
&lt;li&gt;Constraint solving (unification)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;&#x2F;h2&gt;
&lt;p&gt;Java and OCaml are &lt;em&gt;statically typed&lt;&#x2F;em&gt; languages, meaning every binding has
a type that is determined at &lt;em&gt;compile time&lt;&#x2F;em&gt;—that is, before any part of
the program is executed. The type-checker is a compile-time procedure
that either accepts or rejects a program. By contrast, JavaScript and
Ruby are dynamically-typed languages; the type of a binding is not
determined ahead of time and computations like binding 42 to &lt;code&gt;x&lt;&#x2F;code&gt; and
then treating &lt;code&gt;x&lt;&#x2F;code&gt; as a string result in run-time errors.&lt;&#x2F;p&gt;
&lt;p&gt;Unlike Java, OCaml is &lt;em&gt;implicitly typed&lt;&#x2F;em&gt;, meaning programmers rarely need
to write down the types of bindings. This is often convenient,
especially with higher-order functions. (Although some people disagree
as to whether it makes code easier or harder to read). But implicit
typing in no way changes the fact that OCaml is statically typed. Rather,
the type-checker has to be more sophisticated because it must infer what
the &lt;em&gt;type annotations&lt;&#x2F;em&gt; “would have been” had the programmers written all
of them. In principle, type inference and type checking could be
separate procedures (the inferencer could figure out the types then the
checker could determine whether the program is well-typed), but in
practice they are often merged into a single procedure called
&lt;em&gt;type reconstruction&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ocaml-type-reconstruction&quot;&gt;OCaml type reconstruction&lt;&#x2F;h2&gt;
&lt;p&gt;OCaml was rather cleverly designed so that type reconstruction is a
straightforward algorithm. At a very high level, that algorithm works as
follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Determine the types of definitions in order, using the types of earlier
definitions to infer the types of later ones. (Which is one reason you
may not use a name before it is bound in an OCaml program.)&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;For each &lt;code&gt;let&lt;&#x2F;code&gt; definition, analyze the definition to determine
&lt;em&gt;constraints&lt;&#x2F;em&gt; about its type. For example, if the inferencer sees
&lt;code&gt;x+1&lt;&#x2F;code&gt;, it concludes that &lt;code&gt;x&lt;&#x2F;code&gt; must have type &lt;code&gt;int&lt;&#x2F;code&gt;. It gathers
similar constraints for function applications, pattern matches, etc.
Think of these constraints as a system of equations like you might
have in algebra.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Use that system of equations to solve for the type of the name
begin defined.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The OCaml type reconstruction algorithm attempts to never reject a
program that could type-check, if the programmer had written down types.
It also attempts never to accept a program that cannot possibly type
check. Some more obscure parts of the language can sometimes make type
annotations either necessary or at least helpful (see RWO chapter 22,
“Type inference”, for examples).  But for most code you write, type
annotations really are completely optional.&lt;&#x2F;p&gt;
&lt;p&gt;Since it would be verbose to keep writing “the OCaml type reconstruction
algorithm,” we’ll call the algorithm HM. That name is used throughout
the programming languages literature, because the algorithm was
independently invented by Roger &lt;u&gt;H&lt;&#x2F;u&gt;indley and Robin &lt;u&gt;M&lt;&#x2F;u&gt;ilner.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;collecting-and-solving-constraints-examples&quot;&gt;Collecting and solving constraints: Examples&lt;&#x2F;h2&gt;
&lt;p&gt;To gather the constraints for a definition, HM does the following:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Assign a preliminary type to every subexpression in the definition.
For known operations and constants, such as &lt;code&gt;+&lt;&#x2F;code&gt; and &lt;code&gt;3&lt;&#x2F;code&gt;, use the
type that is already known for it. For anything else, use a new type
variable that hasn’t been used anywhere else.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Use the “shape” of the expressions to generate constraints. For
example, if an expression involves applying a function to an
argument, then generate a constraint requiring the type of the
argument to be the same as the function’s input type.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We’ll give some examples of this first, then we’ll give the algorithms
for doing it.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-1&quot;&gt;Example 1.&lt;&#x2F;h4&gt;
&lt;p&gt;Here’s an example utop interaction:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;# let g x = 5 + x;;
&lt;&#x2F;span&gt;&lt;span&gt;val g : int -&amp;gt; int = &amp;lt;fun&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;How did OCaml infer the type of &lt;code&gt;g&lt;&#x2F;code&gt; here?  Let’s work it out.&lt;&#x2F;p&gt;
&lt;p&gt;First, let’s rewrite &lt;code&gt;g&lt;&#x2F;code&gt; syntactically to make our work a little easier:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;let g = fun x -&amp;gt; ((+) 5) x
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We’ve made the anonymous function explicit, and we’ve made the
binary infix operator a prefix function application.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1. Assign preliminary types.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;For each subexpression of &lt;code&gt;fun x -&amp;gt; (+) 5 x&lt;&#x2F;code&gt;, including the entire
expression itself, we assign a preliminary type. We already know the
types of &lt;code&gt;(+)&lt;&#x2F;code&gt; and &lt;code&gt;5&lt;&#x2F;code&gt;, because those are baked into the language
itself, but for everything else we “play dumb” and just invent a new
type variable for it. For now we will use uppercase letters to represent
those type variables, rather than the OCaml syntax for type variables
(e.g., &lt;code&gt;&#x27;a&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Subexpression         Preliminary type
&lt;&#x2F;span&gt;&lt;span&gt;------------------    --------------------
&lt;&#x2F;span&gt;&lt;span&gt;fun x -&amp;gt; ((+) 5) x    R
&lt;&#x2F;span&gt;&lt;span&gt;    x                 U
&lt;&#x2F;span&gt;&lt;span&gt;         ((+) 5) x    S
&lt;&#x2F;span&gt;&lt;span&gt;         ((+) 5)      T
&lt;&#x2F;span&gt;&lt;span&gt;          (+)         int -&amp;gt; (int -&amp;gt; int)
&lt;&#x2F;span&gt;&lt;span&gt;              5       int
&lt;&#x2F;span&gt;&lt;span&gt;                 x    V
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;2. Collect constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Here are some observations we could make about the “shape” of subexpressions
and some relationships among them:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Since function argument &lt;code&gt;x&lt;&#x2F;code&gt; has type &lt;code&gt;U&lt;&#x2F;code&gt; and function body &lt;code&gt;((+) 5) x&lt;&#x2F;code&gt;
has type &lt;code&gt;S&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;R&lt;&#x2F;code&gt;, the type of the anonymous
function expression, satisfies the constraint &lt;code&gt;R = U -&amp;gt; S&lt;&#x2F;code&gt;.
That is, &lt;em&gt;the type of the anonymous function&lt;&#x2F;em&gt; is &lt;em&gt;the type of its argument&lt;&#x2F;em&gt;
arrow &lt;em&gt;the type of its body&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Since function &lt;code&gt;((+) 5)&lt;&#x2F;code&gt; has type &lt;code&gt;T&lt;&#x2F;code&gt; and function
application &lt;code&gt;((+) 5) x&lt;&#x2F;code&gt; has type &lt;code&gt;S&lt;&#x2F;code&gt;, and since the argument &lt;code&gt;x&lt;&#x2F;code&gt; has
type &lt;code&gt;V&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;T = V -&amp;gt; S&lt;&#x2F;code&gt;.  That is,
&lt;em&gt;the type of the function being applied&lt;&#x2F;em&gt; is &lt;em&gt;the type of the argument it’s
being applied to&lt;&#x2F;em&gt; arrow &lt;em&gt;the type of the function application expression&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Since function &lt;code&gt;(+)&lt;&#x2F;code&gt; has type &lt;code&gt;int -&amp;gt; (int -&amp;gt; int)&lt;&#x2F;code&gt; and function
application &lt;code&gt;(+) 5&lt;&#x2F;code&gt; has type &lt;code&gt;T&lt;&#x2F;code&gt;, and since the argument &lt;code&gt;5&lt;&#x2F;code&gt;
has type &lt;code&gt;int&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;int -&amp;gt; (int-&amp;gt;int) = int -&amp;gt; T&lt;&#x2F;code&gt;.
Once again,
&lt;em&gt;the type of the function being applied&lt;&#x2F;em&gt; is &lt;em&gt;the type of the argument it’s
being applied to&lt;&#x2F;em&gt; arrow &lt;em&gt;the type of the function application expression&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Since &lt;code&gt;x&lt;&#x2F;code&gt; occurs with both type &lt;code&gt;U&lt;&#x2F;code&gt; and &lt;code&gt;V&lt;&#x2F;code&gt;, it must be the case that &lt;code&gt;U = V&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The set of constraints thus generated is:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;                  U = V
&lt;&#x2F;span&gt;&lt;span&gt;                  R = U -&amp;gt; S
&lt;&#x2F;span&gt;&lt;span&gt;                  T = V -&amp;gt; S
&lt;&#x2F;span&gt;&lt;span&gt;int -&amp;gt; (int -&amp;gt; int) = int -&amp;gt; T
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;3. Solve constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You can solve that system of equations easily. Starting from the last
constraint, we know &lt;code&gt;T&lt;&#x2F;code&gt; must be &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt;. Substituting that into the
second constraint, we get that &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt; must equal &lt;code&gt;V -&amp;gt; S&lt;&#x2F;code&gt;, hence
&lt;code&gt;V = S = int&lt;&#x2F;code&gt;. Since &lt;code&gt;U=V&lt;&#x2F;code&gt;, &lt;code&gt;U&lt;&#x2F;code&gt; must also be &lt;code&gt;int&lt;&#x2F;code&gt;. Substituting for &lt;code&gt;S&lt;&#x2F;code&gt;
and &lt;code&gt;U&lt;&#x2F;code&gt; in the first constraint, we get that &lt;code&gt;R = int -&amp;gt; int&lt;&#x2F;code&gt;. So the
inferred type of &lt;code&gt;g&lt;&#x2F;code&gt; is &lt;code&gt;int -&amp;gt; int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-2&quot;&gt;Example 2.&lt;&#x2F;h4&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;# let apply f x = f x;;
&lt;&#x2F;span&gt;&lt;span&gt;val apply : (&amp;#39;a -&amp;gt; &amp;#39;b) -&amp;gt; &amp;#39;a -&amp;gt; &amp;#39;b = &amp;lt;fun&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Again we rewrite:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;let apply = fun f -&amp;gt; (fun x -&amp;gt; f x)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;1. Assign preliminary types.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Subexpression              Preliminary type
&lt;&#x2F;span&gt;&lt;span&gt;-----------------------    ------------------
&lt;&#x2F;span&gt;&lt;span&gt;fun f -&amp;gt; (fun x -&amp;gt; f x)    R
&lt;&#x2F;span&gt;&lt;span&gt;    f                      S
&lt;&#x2F;span&gt;&lt;span&gt;         (fun x -&amp;gt; f x)    T
&lt;&#x2F;span&gt;&lt;span&gt;              x            U
&lt;&#x2F;span&gt;&lt;span&gt;                   f x     V
&lt;&#x2F;span&gt;&lt;span&gt;                   f       S
&lt;&#x2F;span&gt;&lt;span&gt;                     x     U
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;2. Collect constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R = S -&amp;gt; T&lt;&#x2F;code&gt;, because of the anonymous function expression.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;T = U -&amp;gt; V&lt;&#x2F;code&gt;, because of the nested anonymous function expression.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;S = U -&amp;gt; V&lt;&#x2F;code&gt;, because of the function application.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;3. Solve constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Using the third constraint, and substituting for &lt;code&gt;S&lt;&#x2F;code&gt; in the first
constraint, we have that &lt;code&gt;R = (U -&amp;gt; V) -&amp;gt; T&lt;&#x2F;code&gt;.  Using the second
constraint, and substituting for &lt;code&gt;T&lt;&#x2F;code&gt; in the first constraint,
we have that &lt;code&gt;R = (U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V)&lt;&#x2F;code&gt;.  There are no further
substitutions that can be made, so we’re done solving the constraints.
If we now replace the preliminary type variables with actual OCaml
type variables, specifically &lt;code&gt;U&lt;&#x2F;code&gt; with &lt;code&gt;&#x27;a&lt;&#x2F;code&gt; and &lt;code&gt;V&lt;&#x2F;code&gt; with &lt;code&gt;&#x27;b&lt;&#x2F;code&gt;, we get that
the type of &lt;code&gt;apply&lt;&#x2F;code&gt; is &lt;code&gt;(&#x27;a -&amp;gt; &#x27;b) -&amp;gt; (&#x27;a -&amp;gt; &#x27;b)&lt;&#x2F;code&gt;, which is the same as
&lt;code&gt;(&#x27;a -&amp;gt; &#x27;b) -&amp;gt; &#x27;a -&amp;gt; &#x27;b&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-3&quot;&gt;Example 3.&lt;&#x2F;h4&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;# apply g 3;;
&lt;&#x2F;span&gt;&lt;span&gt;- : int = 8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We rewrite that as &lt;code&gt;(apply g) 3&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;1. Assign preliminary types.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In this running example, the inference for &lt;code&gt;g&lt;&#x2F;code&gt; and &lt;code&gt;apply&lt;&#x2F;code&gt; has already
been done, so we can fill in their types as known, much like the type
of &lt;code&gt;+&lt;&#x2F;code&gt; is already known.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;Subexpression     Preliminary type
&lt;&#x2F;span&gt;&lt;span&gt;-------------     ------------------------------------------
&lt;&#x2F;span&gt;&lt;span&gt;(apply g) 3       R
&lt;&#x2F;span&gt;&lt;span&gt;(apply g)         S  
&lt;&#x2F;span&gt;&lt;span&gt; apply            (U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V)
&lt;&#x2F;span&gt;&lt;span&gt;       g          int -&amp;gt; int
&lt;&#x2F;span&gt;&lt;span&gt;          3       int
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;2. Collect constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;S = int -&amp;gt; R&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;`(U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V) = (int -&amp;gt; int) -&amp;gt; S&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;3. Solve constraints.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Breaking down the last constraint, we have that &lt;code&gt;U = V = int&lt;&#x2F;code&gt;, and
that &lt;code&gt;S = U -&amp;gt; V&lt;&#x2F;code&gt;, hence &lt;code&gt;S = int -&amp;gt; int&lt;&#x2F;code&gt;.  Substituting that into
the first constraint, we have that &lt;code&gt;int -&amp;gt; int = int -&amp;gt; R&lt;&#x2F;code&gt;.  Therefore
&lt;code&gt;R = int&lt;&#x2F;code&gt;, so the type of &lt;code&gt;apply g 3&lt;&#x2F;code&gt; is &lt;code&gt;int&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;example-4&quot;&gt;Example 4.&lt;&#x2F;h4&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;# apply not false;;
&lt;&#x2F;span&gt;&lt;span&gt;- : bool = true
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;By essentially the same reasoning as in example 3, HM can infer that the
type of this expression is &lt;code&gt;bool&lt;&#x2F;code&gt;. This illustrates the polymorphism of
&lt;code&gt;apply&lt;&#x2F;code&gt;: because the type &lt;code&gt;(U -&amp;gt; V) -&amp;gt; (U -&amp;gt; V)&lt;&#x2F;code&gt; of
&lt;code&gt;apply&lt;&#x2F;code&gt; contains type variables, the function can be applied to any
arguments, so long as those arguments’ types can be consistently
substituted for the type variables.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;collecting-constraints-algorithm&quot;&gt;Collecting constraints: Algorithm&lt;&#x2F;h2&gt;
&lt;p&gt;We now present an algorithm that generates constraints. This algorithm
is a precise description of how constraint gathering works in the
examples we discussed above. The algorithm is not exactly what HM does,
because HM actually performs type checking at the same time as type
inference. However, the resulting types are the same, and separating
inference from checking hopefully will give you a clearer idea of how
inference itself works.&lt;&#x2F;p&gt;
&lt;p&gt;The algorithm takes as input an expression &lt;code&gt;e&lt;&#x2F;code&gt;. We’ll
assume that every function &lt;code&gt;fun x -&amp;gt; e&#x27;&lt;&#x2F;code&gt; in that expression has an
argument with a different name. (If not, our algorithm could make a
pre-pass to rename variables. This is feasible because of lexical scope.)
The output of the algorithm is a set of constraints.&lt;&#x2F;p&gt;
&lt;p&gt;The first thing the algorithm does is to assign unique preliminary
type variables, e.g. &lt;code&gt;R&lt;&#x2F;code&gt; or &lt;code&gt;S&lt;&#x2F;code&gt;,&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;one to each &lt;em&gt;defining&lt;&#x2F;em&gt; occurrence of a variable, which could be as
a function argument or a let binding, and&lt;&#x2F;li&gt;
&lt;li&gt;one to each occurrence of each subexpression of &lt;code&gt;e&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Call the type variable assigned to &lt;code&gt;x&lt;&#x2F;code&gt; in the former clause
&lt;code&gt;D(x)&lt;&#x2F;code&gt;, and call the type variable assigned to occurrence of a
subexpression &lt;code&gt;e&#x27;&lt;&#x2F;code&gt; in the latter clause &lt;code&gt;U(e&#x27;)&lt;&#x2F;code&gt;.  The names of these
are mnemonics:  &lt;code&gt;U&lt;&#x2F;code&gt; stands for the &lt;u&gt;u&lt;&#x2F;u&gt;se of an expression,
and &lt;code&gt;D&lt;&#x2F;code&gt; stands for the &lt;u&gt;d&lt;&#x2F;u&gt;efinition of a variable name.&lt;&#x2F;p&gt;
&lt;p&gt;Next, the algorithm generates the following constraints:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;For integer constants &lt;code&gt;n&lt;&#x2F;code&gt;:  &lt;code&gt;U(n) = int&lt;&#x2F;code&gt;.  This constraints follows
from the type checking rule for integers, which says that every
integer constant has type &lt;code&gt;int&lt;&#x2F;code&gt;.  Constraints for other types of
constants are generated in a similar way.&lt;&#x2F;li&gt;
&lt;li&gt;For variables &lt;code&gt;x&lt;&#x2F;code&gt;:  &lt;code&gt;D(x) = U(x)&lt;&#x2F;code&gt;.  This constraint follows from the type
checking rule for variables, which says the type of a variable use (in this case, &lt;code&gt;U(x)&lt;&#x2F;code&gt;)
must be the same as the type at which that variable was defined (here, &lt;code&gt;D(x)&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;For function application &lt;code&gt;e1 e2&lt;&#x2F;code&gt;: &lt;code&gt;U(e1) = U(e2) -&amp;gt; U(e1 e2)&lt;&#x2F;code&gt;,
as well as any constraints resulting from &lt;code&gt;e1&lt;&#x2F;code&gt; and &lt;code&gt;e2&lt;&#x2F;code&gt;.  This constraint follows
from the type checking rule for function application.&lt;&#x2F;li&gt;
&lt;li&gt;For anonymous functions &lt;code&gt;fun x -&amp;gt; e&lt;&#x2F;code&gt;: &lt;code&gt;U(fun x -&amp;gt; e) = D(x) -&amp;gt; U(e)&lt;&#x2F;code&gt;,
as well as any constraints resulting from &lt;code&gt;e&lt;&#x2F;code&gt;.  This constraint follows from the
type checking rule for anonymous functions.&lt;&#x2F;li&gt;
&lt;li&gt;For let expressions &lt;code&gt;let x=e1 in e2&lt;&#x2F;code&gt;: &lt;code&gt;D(x)=U(e1)&lt;&#x2F;code&gt;, &lt;code&gt;U(let x=e1 in e2) = U(e2)&lt;&#x2F;code&gt;,
as well as any constraints resulting from &lt;code&gt;e1&lt;&#x2F;code&gt; and &lt;code&gt;e2&lt;&#x2F;code&gt;.  This constraint follows
from the type checking rule for let expressions.&lt;&#x2F;li&gt;
&lt;li&gt;Other expression forms:  similar kinds of constraints likewise derived from the
type checking rule for the expression form.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The result is a set of constraints, which is the output of the
algorithm. It’s not too hard to implement this algorithm as a recursive
function over a tree representing the syntax of &lt;code&gt;e&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Example.&lt;&#x2F;strong&gt;
Given expression &lt;code&gt;fun x -&amp;gt; (fun y -&amp;gt; x)&lt;&#x2F;code&gt;, a type variable &lt;code&gt;R&lt;&#x2F;code&gt; is
associated with argument &lt;code&gt;x&lt;&#x2F;code&gt;, and &lt;code&gt;S&lt;&#x2F;code&gt; with argument &lt;code&gt;y&lt;&#x2F;code&gt;.  For
subexpressions, &lt;code&gt;T&lt;&#x2F;code&gt; is associated with the occurrence of &lt;code&gt;fun x -&amp;gt; (fun y -&amp;gt; x)&lt;&#x2F;code&gt;, and &lt;code&gt;X&lt;&#x2F;code&gt; with the occurrence of &lt;code&gt;(fun y -&amp;gt; x)&lt;&#x2F;code&gt;, and &lt;code&gt;Y&lt;&#x2F;code&gt; with
the occurrence of &lt;code&gt;x&lt;&#x2F;code&gt;. (Note that the names we’ve chosen for the type
variables are completely arbitrary.) The constraints generated are &lt;code&gt;T = R -&amp;gt; X&lt;&#x2F;code&gt;, and &lt;code&gt;X = S -&amp;gt; Y&lt;&#x2F;code&gt;, and &lt;code&gt;Y = R&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;solving-constraints-algorithm&quot;&gt;Solving constraints: Algorithm&lt;&#x2F;h2&gt;
&lt;p&gt;What does it mean to solve a set of constraints? To answer this
question, we define &lt;em&gt;type substitutions&lt;&#x2F;em&gt;. A type substitution is a map
from a type variable to a type. We’ll write &lt;code&gt;{t&#x2F;X}&lt;&#x2F;code&gt; for the
substitution that maps type variable &lt;code&gt;X&lt;&#x2F;code&gt; to type &lt;code&gt;t&lt;&#x2F;code&gt;. The way a
substitution &lt;code&gt;S&lt;&#x2F;code&gt; operates on a type can be defined recursively:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;S(X)        = if S = {t&#x2F;X} then t else X
&lt;&#x2F;span&gt;&lt;span&gt;S(t1 -&amp;gt; t2) = S(t1) -&amp;gt; S(t2)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;A substitution &lt;code&gt;S&lt;&#x2F;code&gt; can be applied to a constraint &lt;code&gt;t = t&#x27;&lt;&#x2F;code&gt;; the result
&lt;code&gt;S(t = t&#x27;)&lt;&#x2F;code&gt; is defined to be &lt;code&gt;S(t) = S(t&#x27;)&lt;&#x2F;code&gt;. And a substitution can be
applied to a set &lt;code&gt;C&lt;&#x2F;code&gt; of constraints; the result &lt;code&gt;S(C)&lt;&#x2F;code&gt; is the result of
applying &lt;code&gt;S&lt;&#x2F;code&gt; to each of the individual constraints in &lt;code&gt;C&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Given two substitutions &lt;code&gt;S&lt;&#x2F;code&gt; and &lt;code&gt;S&#x27;&lt;&#x2F;code&gt;, we write &lt;code&gt;S;S&#x27;&lt;&#x2F;code&gt; for their
composition: &lt;code&gt;(S;S&#x27;)(t) = S&#x27;(S(t))&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;A substitution &lt;em&gt;unifies&lt;&#x2F;em&gt; a constraint &lt;code&gt;t_1 = t_2&lt;&#x2F;code&gt; if &lt;code&gt;S(t_1) = S(t_2)&lt;&#x2F;code&gt;.
A substitution &lt;code&gt;S&lt;&#x2F;code&gt; unifies a set &lt;code&gt;C&lt;&#x2F;code&gt; of constraints if &lt;code&gt;S&lt;&#x2F;code&gt; unifies every
constraint in &lt;code&gt;C&lt;&#x2F;code&gt;. For example, substitution
&lt;code&gt;S = {int-&amp;gt;int&#x2F;Y};{int&#x2F;X}&lt;&#x2F;code&gt; unifies constraint &lt;code&gt;X -&amp;gt; (X -&amp;gt; int) = int -&amp;gt; Y&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;To solve a set of constraints &lt;code&gt;C&lt;&#x2F;code&gt;, we need to find a substitution that
unifies &lt;code&gt;C&lt;&#x2F;code&gt;. If there are no substitutions that unify &lt;code&gt;C&lt;&#x2F;code&gt;, where &lt;code&gt;C&lt;&#x2F;code&gt;
is the constraints generated from expression &lt;code&gt;e&lt;&#x2F;code&gt;, then &lt;code&gt;e&lt;&#x2F;code&gt; is not
typeable.&lt;&#x2F;p&gt;
&lt;p&gt;To find a substitution that unifies &lt;code&gt;C&lt;&#x2F;code&gt;, we use an algorithm
appropriately called the &lt;em&gt;unification&lt;&#x2F;em&gt; algorithm. It is defined as
follows:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;C&lt;&#x2F;code&gt; is the empty set, then &lt;code&gt;unify(C)&lt;&#x2F;code&gt; is the empty substitution.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;C&lt;&#x2F;code&gt; is the union of a constraint &lt;code&gt;t = t&#x27;&lt;&#x2F;code&gt; with other constraints &lt;code&gt;C&#x27;&lt;&#x2F;code&gt;, then
&lt;code&gt;unify(C)&lt;&#x2F;code&gt; is defined as follows, based on that constraint:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27;&lt;&#x2F;code&gt; are both the same type variable, e.g. &lt;code&gt;X&lt;&#x2F;code&gt;,
then return &lt;code&gt;unify(C&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = X&lt;&#x2F;code&gt; for some type variable &lt;code&gt;X&lt;&#x2F;code&gt;, and &lt;code&gt;X&lt;&#x2F;code&gt; does not occur in &lt;code&gt;t&#x27;&lt;&#x2F;code&gt;,
then let &lt;code&gt;S = {t&#x27;&#x2F;X}&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(S(C&#x27;));S&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t&#x27; = X&lt;&#x2F;code&gt; for some type variable &lt;code&gt;X&lt;&#x2F;code&gt;, and &lt;code&gt;X&lt;&#x2F;code&gt; does not occur in &lt;code&gt;t&lt;&#x2F;code&gt;,
then let &lt;code&gt;S = {t&#x2F;X}&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(S(C&#x27;));S&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = t0 -&amp;gt; t1&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27; = t&#x27;0 -&amp;gt; t&#x27;1&lt;&#x2F;code&gt;,
then let &lt;code&gt;C&#x27;&#x27;&lt;&#x2F;code&gt; be the union of &lt;code&gt;C&#x27;&lt;&#x2F;code&gt; with the constraints
&lt;code&gt;t0 = t&#x27;0&lt;&#x2F;code&gt; and &lt;code&gt;t1 = t&#x27;1&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(C&#x27;&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = t0 * t1&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27; = t&#x27;0 * t&#x27;1&lt;&#x2F;code&gt;,
then let &lt;code&gt;C&#x27;&#x27;&lt;&#x2F;code&gt; be the union of &lt;code&gt;C&#x27;&lt;&#x2F;code&gt; with the constraints
&lt;code&gt;t0 = t&#x27;0&lt;&#x2F;code&gt; and &lt;code&gt;t1 = t&#x27;1&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(C&#x27;&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;if &lt;code&gt;t = (t0, ..., tn) tc&lt;&#x2F;code&gt; and &lt;code&gt;t&#x27; = (t&#x27;0, ..., t&#x27;n) tc&lt;&#x2F;code&gt; for some
type constructor &lt;code&gt;tc&lt;&#x2F;code&gt;,
then let &lt;code&gt;C&#x27;&#x27;&lt;&#x2F;code&gt; be the union of &lt;code&gt;C&#x27;&lt;&#x2F;code&gt; with the constraints
&lt;code&gt;ti = t&#x27;i&lt;&#x2F;code&gt;, and return &lt;code&gt;unify(C&#x27;&#x27;)&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;otherwise, fail. There is no possible unifier.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In the second and third subcases, the check that &lt;code&gt;X&lt;&#x2F;code&gt; should
not occur in &lt;code&gt;t&lt;&#x2F;code&gt; ensures that the algorithm doesn’t produce a cyclic
substitution—for example, &lt;code&gt;{(X -&amp;gt; X) &#x2F; X}&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;It’s possible to prove that the unification algorithm always terminates,
and that it produces a result if and only a unifier actually exists—that
is, if and only if the set of constraints has a solution. Moreover, the
solution the algorithm produces is the &lt;em&gt;most general unifier&lt;&#x2F;em&gt;, in the
sense that if &lt;code&gt;S = unify(C)&lt;&#x2F;code&gt; and &lt;code&gt;S&#x27;&lt;&#x2F;code&gt; unifies &lt;code&gt;C&lt;&#x2F;code&gt;, then there
must exist some &lt;code&gt;S&#x27;&#x27;&lt;&#x2F;code&gt; such that &lt;code&gt;S&#x27; = S;S&#x27;&#x27;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;If &lt;code&gt;R&lt;&#x2F;code&gt; is the type variable assigned to represent the type of the entire
expression &lt;code&gt;e&lt;&#x2F;code&gt;, and if &lt;code&gt;S&lt;&#x2F;code&gt; is the substitution produced by the
algorithm, then &lt;code&gt;S(R)&lt;&#x2F;code&gt; is the type inferred for &lt;code&gt;e&lt;&#x2F;code&gt; by HM type
inference. Call that type &lt;code&gt;t&lt;&#x2F;code&gt;. It’s possible to prove &lt;code&gt;t&lt;&#x2F;code&gt; is the
&lt;em&gt;principal&lt;&#x2F;em&gt; type for the expression, meaning that if &lt;code&gt;e&lt;&#x2F;code&gt; also has type
&lt;code&gt;t&#x27;&lt;&#x2F;code&gt; for any other &lt;code&gt;t&#x27;&lt;&#x2F;code&gt;, then there exists a substitution &lt;code&gt;S&lt;&#x2F;code&gt; such that
&lt;code&gt;t&#x27; = S(t)&lt;&#x2F;code&gt;. So HM actually infers the most lenient type that is possible
for any expression.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;let-expressions&quot;&gt;Let expressions&lt;&#x2F;h2&gt;
&lt;p&gt;Consider the following code:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;let double f z = f (f z) in
&lt;&#x2F;span&gt;&lt;span&gt;(double (fun x -&amp;gt; x+1) 1, double (fun x -&amp;gt; not x) false)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The inferred type for &lt;code&gt;f&lt;&#x2F;code&gt; in &lt;code&gt;double&lt;&#x2F;code&gt; would be &lt;code&gt;X -&amp;gt; X&lt;&#x2F;code&gt;. In the
algorithm we’ve described so far, the use of &lt;code&gt;double&lt;&#x2F;code&gt; in the first
component of the pair would produce the constraint &lt;code&gt;X = int&lt;&#x2F;code&gt;, and the
use of &lt;code&gt;double&lt;&#x2F;code&gt; in the definition of &lt;code&gt;b&lt;&#x2F;code&gt; would produce the constraint &lt;code&gt;X = bool&lt;&#x2F;code&gt;. Those constraints would be contradictory, causing unification
to fail!&lt;&#x2F;p&gt;
&lt;p&gt;There is a very nice solution to this called &lt;em&gt;let-polymorphism&lt;&#x2F;em&gt;, which
is what OCaml actually uses. Let-polymorphism enables a polymorphic
function bound by a &lt;code&gt;let&lt;&#x2F;code&gt; expression behave as though it has multiple
types. The essential idea is to allow each usage of a polymorphic
function to have its own instantiation of the type variables, so that
contradictions like the one above can’t happen.&lt;&#x2F;p&gt;
&lt;p&gt;We won’t cover let-polymorphism here, but you can learn more about it
in the reading given below.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;efficiency-of-hm&quot;&gt;Efficiency of HM&lt;&#x2F;h2&gt;
&lt;p&gt;HM is usually a very efficient algorithm—you’ve probably never had to
wait for the REPL to print the inferred types of your programs. In
practice, it runs in approximately linear time. But in theory, there are
some very strange programs that can cause its running-time to blow up.
(Technically, it’s DEXPTIME-complete.) For fun, try typing the following
code in utop:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#151515;color:#e8e8d3;&quot;&gt;&lt;code&gt;&lt;span&gt;let b = true;;
&lt;&#x2F;span&gt;&lt;span&gt;let f0 = fun x -&amp;gt; x+1;;
&lt;&#x2F;span&gt;&lt;span&gt;let f = fun x -&amp;gt; if b then f0 else fun y -&amp;gt; x y;;
&lt;&#x2F;span&gt;&lt;span&gt;let f = fun x -&amp;gt; if b then f else fun y -&amp;gt; x y;;
&lt;&#x2F;span&gt;&lt;span&gt;(* keep repeating that last line *)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You’ll see the types get longer and longer, and eventually type inference
will cause a notable delay.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-history-of-hm&quot;&gt;The history of HM&lt;&#x2F;h2&gt;
&lt;p&gt;HM has been rediscovered many times by many people. Curry used it
informally in the 1950’s (perhaps even the 1930’s). He wrote it up
formally in 1967 (published 1969). Hindley discovered it independently
in 1969; Morris in 1968; and Milner in 1978. In the realm of logic,
similar ideas go back perhaps as far as Tarski in the 1920’s. Commenting
on this history, Hindley wrote,&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;There must be a moral to this story of continual re-discovery;
perhaps someone along the line should have learned to read. Or someone
else learn to write.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;&#x2F;h2&gt;
&lt;p&gt;Hindley–Milner type inference is one of the core algorithms that
makes the OCaml language, and many other functional languages, possible.
It is fundamentally based on traversing the source code to collect
a system of equations, then solving that system to determine the types.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;terms-and-concepts&quot;&gt;Terms and concepts&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;constraint&lt;&#x2F;li&gt;
&lt;li&gt;Hindley–Milner (HM) type inference algorithm&lt;&#x2F;li&gt;
&lt;li&gt;implicit typing&lt;&#x2F;li&gt;
&lt;li&gt;let polymorphism&lt;&#x2F;li&gt;
&lt;li&gt;preliminary type variable&lt;&#x2F;li&gt;
&lt;li&gt;static typing&lt;&#x2F;li&gt;
&lt;li&gt;substitution&lt;&#x2F;li&gt;
&lt;li&gt;type annotation&lt;&#x2F;li&gt;
&lt;li&gt;type inference&lt;&#x2F;li&gt;
&lt;li&gt;type reconstruction&lt;&#x2F;li&gt;
&lt;li&gt;unification&lt;&#x2F;li&gt;
&lt;li&gt;unifier&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further reading&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;newcatalog.library.cornell.edu&#x2F;catalog&#x2F;8324012&quot;&gt;&lt;em&gt;Types and Programming Languages&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, chapter 22, by Benjamin C. Pierce.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>A Small Test Post for this New Blog</title>
        <published>2021-04-30T00:00:00+00:00</published>
        <updated>2021-04-30T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/first/"/>
        <id>https://slightknack.dev/blog/first/</id>
        
        <content type="html" xml:base="https://slightknack.dev/blog/first/">&lt;h1 id=&quot;hello&quot;&gt;Hello!&lt;&#x2F;h1&gt;
&lt;p&gt;This is my first blog post.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; this is a function
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello!&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;I’m debating whether to keep this up… oh well ;P&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Primary Eye</title>
        <published>2021-03-12T00:00:00+00:00</published>
        <updated>2021-03-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/gallery/eye/"/>
        <id>https://slightknack.dev/gallery/eye/</id>
        
        <content type="html" xml:base="https://slightknack.dev/gallery/eye/">&lt;div class=&quot;narrow-unpadded&quot;&gt;
    &lt;div class=&quot;boxed&quot;&gt;
        &lt;h1 class=&quot;title&quot; style=&quot;margin-top: 20pt;&quot;&gt;Primary Eye&lt;&#x2F;h1&gt;
        &lt;p class=&quot;tag&quot;&gt;
            &lt;a href=&quot;&#x2F;gallery&quot;&gt;Isaac Clayton (2021)&lt;&#x2F;a&gt; ·
            Color pencil on paper, A3 ·
            Rome, Italy
        &lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;style&gt;
body {
    background-color: #000; !important
}

#gallery-div {
    height: 100vh;
    width: 100%;
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    z-index: -999;
}

#gallery-img {
    max-height: 80vh;
    max-width: 100%;
    margin: 0;
    margin-left: auto;
    margin-right: auto;
    padding: 0;
    border-radius: 0;
}

#gallery-spacer {
    height: 100vh;
}

@media only screen and (max-width: 900px) {
    body {
        background-color: var(--fill-bg); !important;
    }

    #gallery-div {
        height: initial;
        width: 100%;
        position: static;
    }

    #gallery-spacer {
        height: 0;
    }
}
&lt;&#x2F;style&gt;
&lt;div id=&quot;gallery-div&quot;&gt;
    &lt;img id=&quot;gallery-img&quot; src=&quot;&amp;#x2F;content&amp;#x2F;eye.jpg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div id=&quot;gallery-spacer&quot;&gt;&lt;&#x2F;div&gt;

&lt;div class=&quot;narrow-unpadded&quot; style=&quot;background: var(--fill-bg); padding: 20pt; padding-top: 1pt; padding-bottom: 1pt; margin-bottom: 20pt; border-radius: 20pt;&quot;&gt;
&lt;h1 style=&quot;margin-top: 20pt&quot;&gt;Statement&lt;&#x2F;h1&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;Red, Yellow, Blue. These are the oft-repeated primary colors, but they are only a half-truth.&lt;&#x2F;p&gt;
&lt;p&gt;There are really two sets of primary colors; which one to use depends on the type of light you’re working with. For additive light, like that emitted by screens, the primary colors are Red, Green, and Blue — RGB.&lt;&#x2F;p&gt;
&lt;p&gt;The physical medium, on the other hand, is subtractive. Adding colored pigment to paper removes a fraction of the light being reflected off it. The primary colors of subtractive light are Cyan, Magenta, and Yellow (and Black) — CMYK.&lt;&#x2F;p&gt;
&lt;p&gt;It’s funny, then, that artists stick to Red, Yellow, and Blue. Artfully selected primaries create nuanced mood; why do we leave a fraction of the spectrum unexplored?&lt;&#x2F;p&gt;
&lt;p&gt;In this piece, I used only the 4 subtractive primaries, as seen in the bottom-left corner. This was a fun exercise in pulling out the components of colors, carefully mixing opposites to create a perfect shade in the middle.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Vaporization and Modern Memory Management</title>
        <published>2021-02-24T00:00:00+00:00</published>
        <updated>2021-02-24T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/vaporization/"/>
        <id>https://slightknack.dev/passerine/vaporization/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;This piece is a work in progress.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;An interesting design space in the field of programming language design is that of memory management. In short, programs produce data while running. This in of itself isn’t much of a problem: in fact, it’s a good thing! If your programming language doesn’t allow for the production of any useful data, you might want to take a closer look at it…&lt;&#x2F;p&gt;
&lt;p&gt;As time goes on, our program may no longer needs certain data. We could just leave this garbage floating around forever, but, alas computers a finite amount of space to work with. It’s trivial to produce useful data; the more difficult task is figuring out when it’s no longer needed.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>FFIs [Were] Hard</title>
        <published>2020-12-12T00:00:00+00:00</published>
        <updated>2020-12-12T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/ffi-hard/"/>
        <id>https://slightknack.dev/passerine/ffi-hard/</id>
        
        <content type="html" xml:base="https://slightknack.dev/passerine/ffi-hard/">&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;This post was written early on in Passerine’s development, before we had an FFI to interact with Rust. The FFI is still not fully finalized; most notably, as of writing this header, we need to still implement serde-style macros to easily interface with Rust datatypes, implement a module system to allow for external modules, and (eventually) allow for FFI interaction w&#x2F; Wasm modules for cross-platform FFI support.&lt;&#x2F;p&gt;
&lt;p&gt;It’s possible to add two numbers in Passerine now, don’t worry ;D&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;or-why-you-can-t-even-add-two-numbers-in-passerine-yet&quot;&gt;Or, why you can’t even add two numbers in Passerine yet.&lt;&#x2F;h2&gt;
&lt;p&gt;I figure someone will ask this question eventually, so I’m writing this response now. Foreign Functional Interfaces are hard. Not conceptually speaking — I could probably crank (an admittedly bad one) out in an afternoon — but in terms of designing a solution with an active admonition of traits Passerine strives to embody.&lt;&#x2F;p&gt;
&lt;p&gt;Above all else, Passerine strives to be a &lt;em&gt;concise&lt;&#x2F;em&gt; language, in terms of design and implementation. What does this mean? I mean concision on two fronts:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The language and it’s implementation should be simple. You should be able to keep the entire system in your head, and understand how everything fits together.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;The language and it’s implementation should be combinatorial. Although the language should be simple, it should feel as friction-less as possible. The answer to “Wait, can A and B work together like this?” should always be “Woah, I wasn’t expecting that to work, but it makes so much sense”&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;These goals are slightly conflicting. To build a system where everything composes together perfectly requires Good Architecture™ to be in place. Essentially, &lt;code&gt;MxN&lt;&#x2F;code&gt; problems need to be reduced to &lt;code&gt;Mx1, 1xN&lt;&#x2F;code&gt; problems wherever possible.&lt;&#x2F;p&gt;
&lt;p&gt;So right, back to Passerine. Why can’t you add you numbers yet?&lt;&#x2F;p&gt;
&lt;p&gt;Adding, like any other operation, is a function. There’s nothing too special about adding when compared to subtraction, multiplication, etc. – two operands in, one value out.&lt;&#x2F;p&gt;
&lt;p&gt;What’s my point? To simplify Passerine on the two fronts mentioned above, I’m opting to build an extensible FFI system into Passerine, through which I’ll implement performance critical parts of the standard library as well as common operations on data. Instead of defining an add operator in the language itself (which dispatches on type to perform the correct operation) Passerine will simply use FFI bindings to do this.&lt;&#x2F;p&gt;
&lt;p&gt;It’s critical that this FFI be fast, which is why it’ll bind to Rust, and be compiled against the language core. In the future, I hope that something like this is possible:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; &#x2F;ffi&#x2F;thing.rs
&lt;&#x2F;span&gt;&lt;span&gt;use passerine::{&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, Data, Runtime};
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;passerine&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;bind&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fbfdc;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;some_ffi_fn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#ffb964;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span&gt;: Data) -&amp;gt; Result&amp;lt;Data, Runtime&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#888888;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;elm&quot; style=&quot;background-color:#151515;color:#e8e8d3;&quot; class=&quot;language-elm &quot;&gt;&lt;code class=&quot;language-elm&quot; data-lang=&quot;elm&quot;&gt;&lt;span style=&quot;color:#888888;&quot;&gt;-- &#x2F;src&#x2F;main.pn
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;use &lt;&#x2F;span&gt;&lt;span&gt;extern thing.some_ffi_fn
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#fad07a;&quot;&gt;print &lt;&#x2F;span&gt;&lt;span&gt;some_ffi_fn (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#99ad6a;&quot;&gt;Hello, World&lt;&#x2F;span&gt;&lt;span style=&quot;color:#556633;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#cf6a4c;&quot;&gt;27.5&lt;&#x2F;span&gt;&lt;span&gt;)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is great because it allows for two things:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;New operations can be quickly added to passerine. It’ll be literally updating the lexer and parser, then writing a few lines of Rust&lt;&#x2F;li&gt;
&lt;li&gt;This FFI will allows users to define their &lt;em&gt;own&lt;&#x2F;em&gt; Rust functions that can be called from Passerine allowing for easier integration with existing Rust libraries.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Of course, before this is possible, a few things need to be done:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;I need to flesh out pattern matching and the type system. This is what I’m working on now.&lt;&#x2F;li&gt;
&lt;li&gt;I need to start working on fibers, and concurrency in Passerine’s primary runtime environment, Aspen&lt;&#x2F;li&gt;
&lt;li&gt;I need to implement a module system, so using scoped FFI functions feels like using yet another Passerine module&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Of course, there are a few quality-of-life things I need to organize before I get started with this:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;People have shown interest in trying out, developing, and contributing to Passerine. Up until this point, it’s been a one-man team, so I need to figure out how to more actively engage the community towards building something rather than just asking for feedback from time to time.&lt;&#x2F;li&gt;
&lt;li&gt;There is little tooling for Passerine. I’ve tossed together a bare-bones syntax highlighter I’m too embarrassed to publish, but I hope to polish it up and get it out the door soon.&lt;&#x2F;li&gt;
&lt;li&gt;Although I’ve had a lot of free time due to COVID-19 (the largest driver of Passerine’s development by far, ironically), I still have to attend classes, do homework, and fulfill other commitments I’ve made.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;I appreciate the interest. As always, if you have any questions, comments, or suggestions, you know where to find me!&lt;&#x2F;p&gt;
&lt;p&gt;Have a nice one y’all,&lt;br &#x2F;&gt;
Isaac Clayton&lt;&#x2F;p&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>Mr. Covid 19</title>
        <published>2020-11-10T00:00:00+00:00</published>
        <updated>2020-11-10T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/gallery/covid/"/>
        <id>https://slightknack.dev/gallery/covid/</id>
        
        <content type="html" xml:base="https://slightknack.dev/gallery/covid/">&lt;div class=&quot;narrow-unpadded&quot;&gt;
    &lt;div class=&quot;boxed&quot;&gt;
        &lt;h1 class=&quot;title&quot; style=&quot;margin-top: 20pt;&quot;&gt;Mr. Covid 19&lt;&#x2F;h1&gt;
        &lt;p class=&quot;tag&quot;&gt;
            &lt;a href=&quot;&#x2F;gallery&quot;&gt;Isaac Clayton (2020)&lt;&#x2F;a&gt; ·
            Chalk on paper, A4 ·
            Rome, Italy
        &lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;style&gt;
body {
    background-color: #000; !important
}

#gallery-div {
    height: 100vh;
    width: 100%;
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    z-index: -999;
}

#gallery-img {
    max-height: 80vh;
    max-width: 100%;
    margin: 0;
    margin-left: auto;
    margin-right: auto;
    padding: 0;
    border-radius: 0;
}

#gallery-spacer {
    height: 100vh;
}

@media only screen and (max-width: 900px) {
    body {
        background-color: var(--fill-bg); !important;
    }

    #gallery-div {
        height: initial;
        width: 100%;
        position: static;
    }

    #gallery-spacer {
        height: 0;
    }
}
&lt;&#x2F;style&gt;
&lt;div id=&quot;gallery-div&quot;&gt;
    &lt;img id=&quot;gallery-img&quot; src=&quot;&amp;#x2F;content&amp;#x2F;covid.jpg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div id=&quot;gallery-spacer&quot;&gt;&lt;&#x2F;div&gt;

&lt;div class=&quot;narrow-unpadded&quot; style=&quot;background: var(--fill-bg); padding: 20pt; padding-top: 1pt; padding-bottom: 1pt; margin-bottom: 20pt; border-radius: 20pt;&quot;&gt;
&lt;h1 style=&quot;margin-top: 20pt&quot;&gt;Statement&lt;&#x2F;h1&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;Towards the middle of the COVID pandemic, I was doing hybrid learning. We had a skeleton wearing a mask in the art room for whatever reason: an interesting subject for a sketch, so I sketched it.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>From 10° to 10⁻³</title>
        <published>2020-10-15T00:00:00+00:00</published>
        <updated>2020-10-15T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/gallery/ten/"/>
        <id>https://slightknack.dev/gallery/ten/</id>
        
        <content type="html" xml:base="https://slightknack.dev/gallery/ten/">&lt;div class=&quot;narrow-unpadded&quot;&gt;
    &lt;div class=&quot;boxed&quot;&gt;
        &lt;h1 class=&quot;title&quot; style=&quot;margin-top: 20pt;&quot;&gt;From 10⁰ to 10⁻³&lt;&#x2F;h1&gt;
        &lt;p class=&quot;tag&quot;&gt;
            &lt;a href=&quot;&#x2F;gallery&quot;&gt;Isaac Clayton (2020)&lt;&#x2F;a&gt; ·
            Watercolor on hot-pressed paper, approx. A3 ·
            Rome, Italy
        &lt;&#x2F;p&gt;
    &lt;&#x2F;div&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;&lt;style&gt;
body {
    background-color: #000; !important
}

#gallery-div {
    height: 100vh;
    width: 100%;
    display: flex;
    align-items: center;
    position: fixed;
    top: 0;
    z-index: -999;
}

#gallery-img {
    max-height: 80vh;
    max-width: 100%;
    margin: 0;
    margin-left: auto;
    margin-right: auto;
    padding: 0;
    border-radius: 0;
}

#gallery-spacer {
    height: 100vh;
}

@media only screen and (max-width: 900px) {
    body {
        background-color: var(--fill-bg); !important;
    }

    #gallery-div {
        height: initial;
        width: 100%;
        position: static;
    }

    #gallery-spacer {
        height: 0;
    }
}
&lt;&#x2F;style&gt;
&lt;div id=&quot;gallery-div&quot;&gt;
    &lt;img id=&quot;gallery-img&quot; src=&quot;&amp;#x2F;content&amp;#x2F;ten.jpg&quot;&gt;
&lt;&#x2F;div&gt;
&lt;div id=&quot;gallery-spacer&quot;&gt;&lt;&#x2F;div&gt;

&lt;div class=&quot;narrow-unpadded&quot; style=&quot;background: var(--fill-bg); padding: 20pt; padding-top: 1pt; padding-bottom: 1pt; margin-bottom: 20pt; border-radius: 20pt;&quot;&gt;
&lt;h1 style=&quot;margin-top: 20pt&quot;&gt;Statement&lt;&#x2F;h1&gt;
&lt;&#x2F;p&gt;
&lt;p&gt;Inspired by the classic short film &lt;em&gt;Powers of Ten&lt;&#x2F;em&gt; from 1977, and the &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.nikonsmallworld.com&#x2F;&quot;&gt;&lt;em&gt;Nikon Small World Photomicrography Competition&lt;&#x2F;em&gt;&lt;&#x2F;a&gt;, this piece combines two imagines of vastly different scales.&lt;&#x2F;p&gt;
&lt;p&gt;On the left is an human-scale image, existing on the order of magnitude of ten to the power of zero. It’s a young girl blowing bubbles; human faces are hard to pin down, so this piece was a practice in proportions. It’s quite visible that I still have a ways to go in this area… 😅&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;oil.jpg&quot; alt=&quot;Oil on water, creating beautiful refraction patterns&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The right mimics a microscopic image, taken at ten to the power of negative three. It’s showing the reflection patterns caused as light bends through water at microscopic scales. The above image was used as a source of inspiration, and was &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;www.nikonsmallworld.com&#x2F;galleries&#x2F;2014-small-world-in-motion-competition&#x2F;oil-on-water&quot;&gt;taken by Dr. John Hart of CU Boulder&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dr. Hart has done a lot of cool photomicrographic work; I highly recommend you &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;http:&#x2F;&#x2F;www.hart3d.com&#x2F;pages&#x2F;gallery-content&#x2F;index.html&quot;&gt;check out his website&lt;&#x2F;a&gt;, where he catalogs a lot of his work in detail.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Bridging the gap between the large and the minuscule are a series of bubbles that progressively transform into micro-droplets of oil on water. This was a large and fun project to work on, and I learned a lot throughout the planning and execution of this piece. Here’s a quick behind-the-scenes of the painting process:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;content&#x2F;ten-wip.jpg&quot; alt=&quot;Work in progress painting on the right, watercolors, tape, and other materials on the left&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Oh, and for those interested, here’s the original &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;0fKBhvDjuy0?t=13&quot;&gt;&lt;em&gt;Powers of Ten&lt;&#x2F;em&gt;&lt;&#x2F;a&gt; video made back in 1977:&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;youtu.be&#x2F;0fKBhvDjuy0?t=13&quot;&gt;&lt;img src=&quot;&#x2F;content&#x2F;powers-of-ten.jpg&quot; alt=&quot;Powers of 10 on YouTube&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
        
    </entry>
    <entry xml:lang="en">
        <title>All You Need are Coroutines and Pattern Matching</title>
        <published>2020-07-10T00:00:00+00:00</published>
        <updated>2020-07-10T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/all-you-need/"/>
        <id>https://slightknack.dev/passerine/all-you-need/</id>
        
        <summary type="html">&lt;blockquote&gt;
&lt;h2 id=&quot;note&quot;&gt;Note&lt;&#x2F;h2&gt;
&lt;p&gt;This is an old post I wrote a while back. My opinions on the subject have changed slightly but this post has historical merit. The date is not entirely accurate, this article coincides with around the time I started seriously implementing Passerine.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;abstract&quot;&gt;Abstract&lt;&#x2F;h2&gt;
&lt;p&gt;The average programmer just wants to write code [citation needed]. Language designers, on the other hand, want to &lt;em&gt;write&lt;&#x2F;em&gt; code, that is, programming languages. Ever since the first lisp interpreter sputtered through it’s first s-exp, there’s been a quest to build a ‘perfect’ programming language. The field of language design remains open, at least in the sense that a better language can always be built. &lt;strong&gt;No matter how hard you try, there is no language that won’t make you clarify your ideas.&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>Architecting Asynchronous Schedulers</title>
        <published>2020-07-10T00:00:00+00:00</published>
        <updated>2020-07-10T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/passerine/schedule/"/>
        <id>https://slightknack.dev/passerine/schedule/</id>
        
        <summary type="html">&lt;h1 id=&quot;note&quot;&gt;Note&lt;&#x2F;h1&gt;
&lt;p&gt;This post explores one design methodology for asynchronous schedulers in the context of a language that is maximally asynchronous, &lt;em&gt;i.e.&lt;&#x2F;em&gt; everything is executed asynchronously. This post is largely a reflection of trying to grapple with &lt;a rel=&quot;noopener nofollow&quot; target=&quot;_blank&quot; href=&quot;https:&#x2F;&#x2F;tokio.rs&#x2F;blog&#x2F;2019-10-scheduler&#x2F;&quot;&gt;this blog post about Tokio’s scheduler&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</summary>
        
    </entry>
    <entry xml:lang="en">
        <title>A Tiny Introduction to Parsers</title>
        <published>2020-07-08T00:00:00+00:00</published>
        <updated>2020-07-08T00:00:00+00:00</updated>
        
        <author>
          <name>
            
              Isaac Clayton
            
          </name>
        </author>
        
        <link rel="alternate" type="text/html" href="https://slightknack.dev/blog/parser/"/>
        <id>https://slightknack.dev/blog/parser/</id>
        
        <summary type="html">&lt;h1 id=&quot;a-question&quot;&gt;A Question&lt;&#x2F;h1&gt;
&lt;p&gt;The other day, someone asked how parsers worked on The Programmer’s Hangout Discord server. Here’s an an abridged version of my explanation.&lt;&#x2F;p&gt;
</summary>
        
    </entry>
</feed>
